---
title: 面试总结
date: 2019-03-15 09:48:09
tags: web前端
---

## React
### 虚拟DOM  
react将真实DOM抽象为虚拟DOM，然后通过新旧虚拟DOM这两个对象的差异(Diff算法)，最终将变化的部分重新渲染，提高效率。  
虚拟dom算法：  
1.用javascript对象表示DOM树的结构，然后用这个树构建一个真正的DOM树，插到文档中。  
2.当状态变更的时候，重新构造一颗新的对象树，然后用对比新旧树，记录差异。 
3.把记录的差异用到步骤1构建的真实DOM树，更新视图  
一句话： 用js对象的形式来表示一颗真实的DOM树。

### react何时同步更新state 
 - 通过添加addEventLister来同步更新state
 - 通过setTimeOut来同步更新state  
 原理： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。
 [react同步更新state](https://zhuanlan.zhihu.com/p/26069727)

 ### React Hooks
 1. react hooks要解决的问题是状态共享，是继render-props和higher-order components之后的第三种状态共享方案，不会产生JSX嵌套地狱问题。状态共享可能描述的不是很恰当，状态逻辑复用，因为只共享数据处理逻辑，不会共享数据本身。
 ```
 function App() {
  return (
    <Toggle initial={false}>
      {({ on, toggle }) => (
        <Button type="primary" onClick={toggle}> Open Modal </Button>
        <Modal visible={on} onOk={toggle} onCancel={toggle} />
      )}
    </Toggle>
  )
}
```
react hooks解决的也是这个问题
```
function App() {
  const [open, setOpen] = useState(false);
  return (
    <>
      <Button type="primary" onClick={() => setOpen(true)}>
        Open Modal
      </Button>
      <Modal
        visible={open}
        onOk={() => setOpen(false)}
        onCancel={() => setOpen(false)}
      />
    </>
  );
}
 ```
 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比,
***这个组件是没有状态的***。

2. 特性： 
- 多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。
- Hooks 可以引用其他 Hooks。
- 更容易将组件的 UI 与状态分离。

3. hooks带来的约定
Hook 函数必须以 "use" 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。
React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。  
因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。  
[参考](https://juejin.im/post/5be8d3def265da611a476231)

### super作用： 
1. 初始化构造函数

### keys作用：
Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。
### setState工作原理
在代码中调用setState函数之后，react会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程，经过调和过程，react会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。react在得到元素树之后，react会自动计算出新的树与老树的节点差异，然后根据差异对界面进行局部更新重渲染。
[详解](https://zhuanlan.zhihu.com/p/20328570?columnSlug=purerender)

### Element与Component的区别
Element是描述屏幕上所见内容的数据结构，是对于UI的对象表述。典型的React Element就是利用JSX构建的声明式代码片然后被转化为createElement的调用组合，而Component则是可以接收参数输入并且返回某个React Element的函数或者类。

### 为什么需要使用React提供的Children API而不是Javascript的map？
props.children获取到的内容可能是object也可能是array,React.Children.map已经将props.children不同类型的情况考虑在内了。

### setState函数的第二个参数的作用是什么？
该函数会在setState函数调用完成并且组件开始重新渲染的时候被调用，我们可以用该函数来监听渲染是否完成。

### react组件类型
- SFC(Stateless Functional Component)
React可以使用Function来创建Component，这类Component没有lifecycle，内部不维护state，只要传入的props有变化则进行重新渲染。

- HOC(Higher-Order Components)
高阶组件就是一个方法，传入一个组件返回另一个组件。最常见的是react-redux里的connect方法，通过传入组件和map*ToProps方法，让组件和store连接。组件内部就可以直接通过props获得connect之后的值。
```
export default connect(
  mapStateToProps,
  mapDispatchToProps,
)(Component);

```
高阶组件适合用来扩展功能，把这部分功能从业务组件中抽离出来，需要的套上，不需要的时候移除，对被包裹组件侵入性非常小

- Dynamic Component
在执行时才能确定具体的标签或者组件是什么
```
render() {
    const { tag: Tag, children } = this.props;
    return <Tag>{ children }</Tag>
}
```

- FaCC(Functions as Child Componets)
React children可以是Function类型，封装一个loading组件，会给children提供loading参数，业务组件贼根据loading判断需要render什么内容
```
class LoadArea extends Component {
  state = {
    loading: true,
  };

  componentDidMount() {
    asyncFunc()
        .then(() => {
            this.setState({
              loading: false,
            })
        })
        .catch(() => {
            this.setState({
              loading: false,
            })
        })
  }

  render() {
    return (
      <React.Fragment>
        {this.props.children({
          ...this.props,
          ...this.state,
        })}
      </React.Fragment>
    );
  }
}



-------------------------------------
render() {
    <LoadingArea>
        ({ loading }) => {
            loading
                ? <Wating />
                : <Main />
        }
    </LoadingArea>
}

```

## Javascript概念
### js微任务/宏任务  
synchronous： 同步任务  
asynchronous：异步任务  
tast queue/callback queue： 任务队列  
execution context stack： 执行栈  
heap： 堆  
stack： 栈  
macro-task： 宏任务  
micro-task： 微任务  
1. js是单线程，将任务分为同步任务和异步任务。一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，结果不过是在执行栈中再添加一个执行环境，这个过程可以是无限进行下去的，除非发生了栈溢出。  
2. 同步和异步任务分别进入不同的执行场所，同步的进入主线程，异步的进入event table并注册函数。当指定的事情完成时，event table会将这个函数移入event queue。主线程内的任务执行完毕为空，会去event queue读取对应的函数，进入主线程执行。上述过程不断重复，也就是常说的Event Loop（事件循环）
3. 
```
let data = [];
$.ajax({
    url:www.javascript.com,
    data:data,
    success:() => {
        console.log('发送成功!');
    }
})
console.log('代码执行结束');

```
一段简易的ajax请求代码，ajax进入event table，注册回调函数success。执行console.log（'代码执行结束'）。ajax事件完成，回调函数success进入event queue。主线程从event queue读取回调函数success并执行。

4. 微任务、宏任务  
微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于它们的执行顺序，event loop的走向和取值。  
js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后在执行微任务，将微任务放入event queue。当你往外拿的时候先从微任务手里拿回调函数，然后再从宏任务的queue上拿宏任务的回调函数。  
宏任务一般： 包括整体代码script, setTimeout, setInterval, setImmediate.  
微任务： 原生Promise（有些实现的promise 将then方法放到了宏任务中）、process.nextTick、MutaionObserver、Object.observer(已废弃)  

参考： [微任务/宏任务详解](https://juejin.im/post/5b498d245188251b193d4059)

### js数组方法
- slice方法返回从该为参数指定位置开始到当前数组末尾的所有项。如果两个参数，该方法返回起始位置和结束位置之间的项但不包括结束位置的项。***该方法不会影响愿数组***
- splice最强大的数组方法：
   
   1. 可以删除任意数量的项，只需指定 2 个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项
   2. 插入:可以向指定位置插入任意数量的项，只需提供 3 个参数:起始位置、0(要删除的项数) 和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如， splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
   3. 替换:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 "red"和"green"。

   splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)
- every和some  
   1. 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true   
   2. 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。
- reduce 遍历数组中的所有项并返回一个最终值。方法接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
### js冻结对象
1. Object.freeze() 冻结一个对象：
 - 不能向这个对象添加新属性  
 - 不能修改其已有属性的值  
 - 不能删除已有属性  
 - 不能修改该对象已有属性的可枚举性、可配置性、可写性

### 函数
1. arguments.callee是为了实现函数更松散的耦合，最简单的实例，函数的递归调用
```
function factorial(num){
    if (num <=1) {
        return 1;
    } else {
        return num * arguments.callee(num-1)
} }
```
2. 函数的属性length和prototype，length属性表示函数希望接收的命名参数的个数。

### 字符串
1. charAt 返回字符串的位置
2. charCodeAt 返回字符串的字符编码
3. concat 用于字符串的拼接
4. slice，substr，sbustring用来获取字符串，不会修改原有字符串返回新的字符串
5. trim方法用来去除字符串的空格，返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变
6. localeCompare 比较两个字符串，返回 -1， 0，1。
```
var stringValue = "yellow"; alert(stringValue.localeCompare("brick")); //1 alert(stringValue.localeCompare("yellow")); //0 alert(stringValue.localeCompare("zoo")); //-1
```

### 对象
- object.defineProperty这个方法 接收三个参数:属性所在的对象、属性的名字和一个描述符对象（必须设置configurable、enumerable、writable 和 value其中的一个值或多个值）。

-  hasOwnProperty()方法可以检测一个属性是存在于实例中

### 柯里化 
为实现多参函数提供了一个递归降解的实现思路---把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数。

### 闭包
1. 可以读取函数内部的变量。
2. 让这些变量的值始终保持在内存中。


### 装饰器  
```
class Cat() {
  say() {
    console.log("meow ~")
  }
}

function Cat() {
  Object.defineProperty(Cat.proptotype, "say", {
    value: function() { console.log("meow ~") },
    enumerable: false,
    configurable: true,
    writable: true
  });
}
-------------------

function readonly(target, name, desciptor) {
  desciptor.writable = false;
  return descriptor
}

class Cat {
  @readonly
  say() {
    console.log("meow `");
  }
}
```

由此可以看出作用于类的属性的时候的装饰器函数接收的参数就是上述ES6中的类定义属性时候使用Object.defineProperty时接收的参数是一样的。

***本质上也就是说装饰器在作用于类的属性的时候，实际上是通过Object.defineProperty***  
装饰一个类：  
装饰一个类的时候本身本质上是一个函数，没有descriptor，target是这个函数本身。  
```
function isAnimal(target) {
    target.isAnimal = true;
  	return target;
}
@isAnimal
class Cat {
    ...
}
console.log(Cat.isAnimal);
```
也就是说，上面的@isAnimal其实就是做了下面这件事：  
`Cat = isAnimal(function Cat() { ... });` 

## ES6
### for in和for of的区别
1. 推荐用for in来遍历对象，for of来遍历数组
2. for in循环出的是key， for of循环出的是value
3. for of 不能循环普通的对象，需要通过和object.keys搭配使用
```
var student={
    name:'wujunchuan',
    age:22,
    locate:{
    country:'china',
    city:'xiamen',
    school:'XMUT'
    }
}
for(var key of Object.keys(student)){
    //使用Object.keys()方法获取对象key的数组
    console.log(key+": "+student[key]);
}
```

## HTTP
### TCP与UDP区别
1. TCP(Transmission Control Protocol)是面向连接的协议，也就是说，在收发数据前必须和对方建立可靠的连接。一个TCP连接需经过3次对话，断开需要经过4次
2. UDP是一个非连接的协议，传输数据之前源端和终端不需建立连接。当他想传送数据时就简单地去抓取来自应用程序的数据，并尽可能地扔到网络上。（常用ping命令检测主机到主机之间是否可通信，就是udp的实例  
区别：
- 基于连接于无连接；
- 对系统资源的要求（TCP较多，UDP较少）
- UDP程序结构较简单
- 流模式与数据报模式
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证

### TCP协议如何提高传输效率
- 滑动窗口
- 快重传
- 延迟应答
- 捎带应答

### HTTP状态码
- 1** 信息，服务器接收到请求，需要请求者继续执行操作。  
  1. 101切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议。
- 2** 成功，操作被成功接收并处理
- 3** 重定向，需要进一步的操作以完成请求
  1. 304未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
- 4** 客户端错误，请求包含语法错误或无法完成请求
- 5** 服务器错误，服务器在处理请求的过程中发生了错误。


## CSS
### BFC
BFC（Block formating context）直译为"块级格式化上下文"。它是一个独立的渲染区域，它规定了北部的block-level-box如何布局，并且与这个区域外部毫不相干。  
形成条件： 
- 浮动元素， float除none以外的值
- 定位元素，position（absolute， fixed）
- display为以为其中之一的值，inline-block，table-cell，table-caption
- overflow除了visible以外的值（hidden，scroll，auto）  

BFC的特性：
- 内部的BOX会在垂直方向上一个接一个的位置
- 垂直方向上的距离由margin决定
- bfc的区域不会于float的元素区域重叠
- 计算bfc的高度时，浮动元素也参与计算
- bfc就是页面上的一个独立容器，容器里面的自元素不会影响外面元素


### position: sticky（兼容性比较低）
粘性定位，是position：relative和postion： fixed的结合体。  
生效规则：
- top, right, bottom, left四个阙值其中之一。
- 设定为position：sticky元素的任意父节点的overflow属性必须是visible，否则position不会生效。  

[参考1](http://www.cnblogs.com/coco1s/p/6402723.html)  
[参考2](https://segmentfault.com/a/1190000006740129)

### box-sizing

1. content-box默认值，标准盒子模型。width与height只包括内容的宽和高，不包括边框，内边距，外边距。尺寸计算公式： width = 内容的宽度，height = 内容的高度。宽度和高度都不包含内容的边框（border）和内边距（padding）

2. border-box width和height属性包括内容，内边距和边框，但不包括外边距。这里的纬度计算公式为： width = border + padding + 内容的width， height = border + padding + 内容的height。