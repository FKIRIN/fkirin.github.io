<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KIRIN&#39;S blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KIRIN&#39;S blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KIRIN&#39;S blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>KIRIN'S blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KIRIN'S blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/js基础常问面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/js基础常问面试题/" itemprop="url">javascript基础面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T09:48:37+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><ul>
<li>prototype<br>Person(构造函数) ———prototype———&gt; Person.prototype(实例原型)。</li>
</ul>
<p>每一个javascript对线（null除外）在创建的时候就会与之关联另一个对像，这个对象就是我们所说的原型。</p>
<ul>
<li><p><strong>proto</strong><br>每一个javascript对象(除了null)都具有一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。<br><img src="/images/2019-9/02-1.jpg" alt="图一"></p>
</li>
<li><p>constructor</p>
</li>
</ul>
<p>每个原型都有一个constructor属性指向关联的构造函数。<img src="/images/2019-9/02-2.jpg" alt="图二"></p>
<ul>
<li>原型链  <blockquote>
<p>Object.getPrototypeOf(obj)或者被弃用的<strong>proto</strong>属性获取对象的原型</p>
</blockquote>
</li>
</ul>
<ol>
<li>Object.prototype.<strong>proto</strong>的值为null<br><img src="/images/2019-9/02-3.jpg" alt="图三"></li>
</ol>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>javascript采用的是词法作用域也就是静态作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>假设javascript采用静态作用域：执行foo函数，先从foo函数内部查找局部变量value。如果没有，就<strong>根据书写的位置（函数调用的位置）</strong>查找上一层的代码，也就是value等于1，所以打印1</li>
<li>假设JavaScript采用动态作用域: 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><p>函数的作用域在函数定义的时候决定了，因为函数有一个内部属性[[scope]],当函数创建的时候，就会保存所有父变量对象到其中，可以理解[[scope]]就是所有父变量对象的层级链。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>MDN定义: 闭包是指那些能够访问自由变量的函数。因此，闭包= 函数 + 函数能够访问的自由变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>执行过程:</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文， checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ol>
<p>当f函数执行完毕的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，之所以能够读取到值正是因为作用域链的存在。<code>fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}</code>.f函数依然可以通过f函数的作用域链访问到它，因而实现了闭包的概念。</p>
<p>实践角度阐释闭包： </p>
<ul>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul>
<li><p>按值传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o = 2;</span><br><span class="line">    console.log(o); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">第一种情况：</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o.value = 2;</span><br><span class="line">    console.log(o.value); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 2</span><br><span class="line"></span><br><span class="line">第二种情况：</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o = 2;</span><br><span class="line">    console.log(o); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>共享传递是传递对象的引用的副本！所以修改o.value可以通过引用找到原址，但是直接修改o，并不会修改原值。</p>
<h3 id="call和apply，bind"><a href="#call和apply，bind" class="headerlink" title="call和apply，bind"></a>call和apply，bind</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。<br>call参数传null的时候，视为指向window.<br>call代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call = function(context) &#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line">  // 首先要获取调用call的函数，用this可以获取</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var args = [];</span><br><span class="line">  for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">    ars.push(&apos;arguments[&apos; + i + &apos;]&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  var result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;);</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apply代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply = function(context, arr) &#123;</span><br><span class="line">  var context = Object(context) || window;</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var result;</span><br><span class="line">  if (!arr) &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125; esle &#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    for (var i = 0, len = arr.length;i &lt; len; i++) &#123;</span><br><span class="line">      ars.push(&apos;arr[&apos; + i + &apos;]&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">参考</a></p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind方法会创建一个新函数，当这个新函数被调用时，bind的第一个参数将作为运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p>特点：</p>
<ul>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ul>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>…arguments可以将类数组转换为数组</p>
<h3 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h3><p>惰性函数就是解决每次都要进行判断的问题，解决原理很简单就是重写函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var foo = function() &#123;</span><br><span class="line">  var t = new Date();</span><br><span class="line">  foo = function() &#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;;</span><br><span class="line">  return foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简化写法</span><br><span class="line">function addEvent (type, el, fn) &#123;</span><br><span class="line">    if (window.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(type, fn, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addEvent = (function()&#123;</span><br><span class="line">    if (window.addEventListener) &#123;</span><br><span class="line">        return function (type, el, fn) &#123;</span><br><span class="line">            el.addEventListener(type, fn, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        return function (type, el, fn) &#123;</span><br><span class="line">            el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会放生改变的时候，可以考虑使用惰性函数。</p>
<h3 id="箭头函数与普通函数的比较"><a href="#箭头函数与普通函数的比较" class="headerlink" title="箭头函数与普通函数的比较"></a>箭头函数与普通函数的比较</h3><ul>
<li>没有this<br>箭头函数没有this,所以需要通过查找作用域链来确定this的值。意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this。</li>
<li>没有arguments<br>箭头函数没有自己的arguments对象，但是箭头函数可以访问外围函数的arguments对象。</li>
<li>不能通过new关键字调用<br>javascript函数有两个内部方法：[[Call]]和[[Construct]]。当通过new调用函数时，执行[[Construct]]方法，创建一个实例对象，然后再执行函数体，将this绑定到实例上。当直接调用的时候，执行[[Call]]方法，直接执行函数体。箭头函数并没有[[Construct]]方法，不能被用作构造函数，如果通过new的方式调用，会报错。</li>
<li>没有new.target<br>因为不能使用new调用，所以也没有new.target值</li>
<li>没有原型<br>由于不能使用new调用箭头函数，也就没有构建原型的需求，于是箭头函数也不存在prototype这个属性。</li>
<li>没有super<br>没有原型，自然也不能通过super来访问原型的属性，箭头函数时没有super的，不过跟this、arguments、new.target一样，这些值由外围最近一层非箭头函数决定。</li>
</ul>
<h3 id="proxy的使用"><a href="#proxy的使用" class="headerlink" title="proxy的使用"></a>proxy的使用</h3><ul>
<li><p>defineProperty</p>
<blockquote>
<p>Object.defineProperty(obj, prop, descriptor)<br>obj: 要在其上定义属性的对象<br>prop: 要定义或修改的属性的名称<br>descriptor: 要将定义或修改的属性的描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch(obj, &quot;value&quot;, function(newvalue)&#123;</span><br><span class="line">    document.getElementById(&apos;container&apos;).innerHTML = newvalue;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">    obj.value += 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">    var root = this;</span><br><span class="line">    function watch(obj, name, func)&#123;</span><br><span class="line">        var value = obj[name];</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(obj, name, &#123;</span><br><span class="line">            get: function() &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function(newValue) &#123;</span><br><span class="line">                value = newValue;</span><br><span class="line">                func(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if (value) obj[name] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.watch = watch;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>proxy<br>使用defineProperty只能重定义属性的读取get和set行为，ES6提供了Proxy，可以重定义更多的行为，比如in、delete、函数调用等更多行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var root = this;</span><br><span class="line"></span><br><span class="line">    function watch(target, func) &#123;</span><br><span class="line"></span><br><span class="line">        var proxy = new Proxy(target, &#123;</span><br><span class="line">            get: function(target, prop) &#123;</span><br><span class="line">                return target[prop];</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function(target, prop, value) &#123;</span><br><span class="line">                target[prop] = value;</span><br><span class="line">                func(prop, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.watch = watch;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newObj = watch(obj, function(key, newvalue) &#123;</span><br><span class="line">    if (key == &apos;value&apos;) document.getElementById(&apos;container&apos;).innerHTML = newvalue;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;button&apos;).addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">    newObj.value += 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用defineProperty和proxy的区别，当使用defineProperty时，我们修改原来的obj对象可以触发拦截，而使用proxy就必须修改代理对象，即proxy的实例才可以触发拦截。</p>
<h3 id="ES6私有变量的实现"><a href="#ES6私有变量的实现" class="headerlink" title="ES6私有变量的实现"></a>ES6私有变量的实现</h3><h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._private = &apos;private&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this._private</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ex = new Example();</span><br><span class="line">console.log(ex.getName()); // private</span><br><span class="line">console.log(ex._private) // private</span><br></pre></td></tr></table></figure>
<p>缺点： </p>
<ol>
<li>外部可以访问和修改</li>
<li>语言没有配合的机制，如for in语句会将所有属性枚举出来<br>优点： </li>
<li>写法简单</li>
<li>调试方便</li>
<li>兼容性好</li>
</ol>
<h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><p>实现一</p>
<blockquote>
<p>constructor方法是类的构造函数，通过new命令创建实例对象时，自动调用该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    var _private = &apos;&apos;;</span><br><span class="line">    _private = &apos;private&apos;;</span><br><span class="line">    this.getName = function() &#123; return _private &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ex = new Example();</span><br><span class="line">console.log(ex.getName()); // private</span><br><span class="line">console.log(ex._private) // undefined</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>缺点：</p>
<ol>
<li>constructor的逻辑变得复杂。构造函数应该只做对象初始化的事情，现在为了实现私有变量，必须包含部分方法的实现，代码组织上略不清晰。</li>
<li>方法存在与实例，而非原型上，子类无法使用super调用。</li>
<li>构建增加一点开销<br>优点： </li>
<li>无命名冲突</li>
<li>外部无法访问和修改</li>
</ol>
<p>实现二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Example = (function() &#123;</span><br><span class="line">  var _private = &apos;&apos;;</span><br><span class="line">  class Example &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      _private = &apos;private&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return _private;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Example;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var ex = new Example();</span><br><span class="line">console.log(ex.getName()); // private</span><br><span class="line">console.log(ex._private) // undefined</span><br></pre></td></tr></table></figure></p>
<p>缺点： </p>
<ol>
<li>写法有点复杂</li>
<li>构建增加一点开销<br>优点：</li>
<li>无命名冲突</li>
<li>外部无法访问和修改</li>
</ol>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Example = (function() &#123;</span><br><span class="line">  vat _private = Symbol(&apos;private&apos;);</span><br><span class="line">  class Example &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      this[_private] = &apos;private&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">          return this[_private];</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Example;</span><br><span class="line">&#125;)()</span><br><span class="line">var ex = new Example();</span><br><span class="line"></span><br><span class="line">console.log(ex.getName()); // private</span><br><span class="line">console.log(ex.name); // undefined</span><br></pre></td></tr></table></figure>
<p>优点:  </p>
<ol>
<li>无命名冲突</li>
<li>外部无法访问和修改</li>
<li>无性能损失</li>
</ol>
<p>缺点:  </p>
<ol>
<li>写法稍微复杂</li>
<li>兼容性也还好</li>
</ol>
<h4 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const Example = (function() &#123;</span><br><span class="line">  var _private = new WeakMap(); // 私有成员存储容器</span><br><span class="line"></span><br><span class="line">  class Example &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      _private.set(this, &apos;private&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">    	return _private.get(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Example;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var ex = new Example();</span><br><span class="line"></span><br><span class="line">console.log(ex.getName()); // private</span><br><span class="line">console.log(ex.name); // undefined</span><br></pre></td></tr></table></figure>
<p>优点: </p>
<ol>
<li>无命名冲突</li>
<li>外部无法访问和修改<br>缺点:  </li>
<li>写法比较麻烦</li>
<li>兼容性有点问题</li>
<li>有一定性能代价</li>
</ol>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  #x;</span><br><span class="line">  #y;</span><br><span class="line"></span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.#x = x;</span><br><span class="line">    this.#y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  equals(point) &#123;</span><br><span class="line">    return this.#x === point.#x &amp;&amp; this.#y === point.#y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">  private value;</span><br><span class="line"></span><br><span class="line">  equals(foo) &#123;</span><br><span class="line">    return this.value === foo.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类的成员函数中可以访问同类型实例的私有变量</strong></p>
<h3 id="es6-class中的constructor方法和super的作用"><a href="#es6-class中的constructor方法和super的作用" class="headerlink" title="es6 class中的constructor方法和super的作用"></a>es6 class中的constructor方法和super的作用</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function() &#123;</span><br><span class="line">  return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价与</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>constructor方法是类的构造函数，是一个默认方法，通过new命令创建对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显示定义，会自动添加构造函数，返回实例对象this。</p>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol>
<li>当作函数使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>在constructor中必须调用super方法，因为子类没有自己的this对象，而是继承父类的this对象，而super就代表类父类的构造函数。super虽然代表类父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super在这里相当于<code>A.prototype.constructor.call(this,props)</code></p>
</blockquote>
<ol start="2">
<li>当作对象使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  c() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.c()); // 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>子类B当中的super.c()就是将super当作一个对象使用，这时，super在普通方法中，指向A.prototype，所以super.c()相当于A.prototype.c()。<br><strong>通过super调用父类的方法时，super会绑定子类的this</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/不了解的javascript基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/不了解的javascript基础/" itemprop="url">不了解的javascript基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T09:48:37+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><h4 id="compatMode"><a href="#compatMode" class="headerlink" title="compatMode"></a>compatMode</h4><p>表明当前文档的渲染模式是混杂模式还是标准模式。</p>
<ul>
<li>混杂模式：BackCompat</li>
<li>标准模式：CSS1Compat<h3 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h3><h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4></li>
</ul>
<p>返回当前元素相对与其offsetParent元素的顶部的距离</p>
<h4 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h4><p>返回一个指向最近的包含该元素的定位元素。如果没有定位元素，则offsetParent为最近的table，table cell或根元素。当元素的style.display设置为“none”时，offsetParent返回null。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间，用来设置flex-grow，flex-shrink，flex-basis；</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/07/git常用技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/git常用技巧/" itemprop="url">git常用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T09:48:37+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul>
<li>git reflog</li>
</ul>
<blockquote>
<p>git reflog可以查看所有分支的所有操作记录（包括已经删除的commit 记录喝reset的操作），例如git reset –hard HEAD~1退回到上一个版本，用git log是看不出来被删除的commitId。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/javascript进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/javascript进阶/" itemprop="url">javascript进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T09:48:37+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote>
<p>func.apply(thisArg, [arsArray])</p>
<ul>
<li>thisArg: func函数运行时使用的this值，当指定为null或undefined时会自动替换为指向全局对象，原始值会被包装</li>
<li>argsArray: 数组或者类数组对象，其中的数组元素将作为单独的参数传给func函数</li>
</ul>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>数组添加到数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">var arr2 = [1, 2];</span><br><span class="line">arr1.push(arr2); // [&apos;a&apos;, &apos;b&apos;, [1, 2]];</span><br><span class="line">arr1.push.apply(arr1, arr2);// [&apos;a&apos;, &apos;b&apos;, 1, 2]</span><br><span class="line"></span><br><span class="line">// 场景2</span><br><span class="line">/* 找出数组中最大/小的数字 */</span><br><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line">var max = Math.max.apply(null, numbers) // 基本等同于 Math.max(numbers[0], ...) 或 Math.max(5, 6, ..)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用apply来链接构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.construct = function(args) &#123;</span><br><span class="line">    var oNew = Object.create(this.prototype);</span><br><span class="line">    &lt;==&gt;</span><br><span class="line">    var oNew = &#123;&#125;;</span><br><span class="line">    oNew.__proto__ = this.prototype;</span><br><span class="line"></span><br><span class="line">    this.apply(oNew, args);</span><br><span class="line">    return oNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="跟call的区别"><a href="#跟call的区别" class="headerlink" title="跟call的区别"></a>跟call的区别</h4><p>在给对象参数的情况下，如果参数的形式是数组的时候，比如apply示例里面传递例参数arguments，这个参数是数组类型，并且在调用Person的时候参数的列表是对应一致的（也就是Person和Student的参数列表前两位是一致的）就可以采用apply，如果Person的参数（age, name）,Student参数列表(name,age, grade)就可以用call来实现，通过Person.call(this, age, name, grade);</p>
<p><strong>apply巧妙的用处可以将一个数组默认的转换为一个参数列表[param1, param2, param3]转换为param1, param2, param3，因为这个特性才有了上述的使用示列</strong></p>
<p><a href="https://blog.csdn.net/qq_35893120/article/details/78890357" target="_blank" rel="noopener">参考</a></p>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h4 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype):"></a>原型(prototype):</h4><ul>
<li>每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象</li>
<li>每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过Object.getPrototypeOf(obj)或obj. __proto__来访问.</li>
<li>实际上，构造函数prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即对象.__proto__ === 函数.prototype</li>
<li>原型对象就是用来存放实例中共有的那部分属性</li>
<li>在JavaScript中，所有的对象都是由他的原型对象继承而来，反之，所有的对象都可以作为原型对象而存在</li>
<li>访问对象的属性时，javascript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。</li>
</ul>
<p>[[prototype]](等同与js的非标准但许多浏览器实现的属性__proto__)可以通过Object.getPrototypeOf()和Object.setPrototypeOf()来访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o = new F()</span><br><span class="line">o.[[prototype]].[[prototype]]是Object.prototype,</span><br><span class="line">最后o.[[prototype]].[[prototype]].[[prototype]]是null</span><br></pre></td></tr></table></figure>
<h4 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h4><p>Object.create()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  m: function()&#123;</span><br><span class="line">    return this.a + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.m()); // 3</span><br><span class="line">// 当调用 o.m 时，&apos;this&apos; 指向了 o.</span><br><span class="line"></span><br><span class="line">var p = Object.create(o);</span><br><span class="line">// p是一个继承自 o 的对象</span><br><span class="line"></span><br><span class="line">p.a = 4; // 创建 p 的自身属性 &apos;a&apos;</span><br><span class="line">console.log(p.m()); // 5</span><br><span class="line">// 调用 p.m 时，&apos;this&apos; 指向了 p</span><br><span class="line">// 又因为 p 继承了 o 的 m 函数</span><br><span class="line">// 所以，此时的 &apos;this.a&apos; 即 p.a，就是 p 的自身属性 &apos;a&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>每个实例对象都有一个私有属性（称之为__proto__）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__),层层向上知道一个对象的原型对象为null,null没有原型，并作为原型链中的最后一个环节。</p>
<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p>
<h4 id="实际执行"><a href="#实际执行" class="headerlink" title="实际执行"></a>实际执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = new Foo()</span><br><span class="line">js实际执行的是</span><br><span class="line">var o= new Object();</span><br><span class="line">o.__proto__ = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数的局限性"><a href="#箭头函数的局限性" class="headerlink" title="箭头函数的局限性"></a>箭头函数的局限性</h3><h4 id="箭头函数的机制"><a href="#箭头函数的机制" class="headerlink" title="箭头函数的机制"></a>箭头函数的机制</h4><p>箭头函数里没有this，所以取到的是定义函数时外部环境的this。</p>
<h4 id="不能使用的场景"><a href="#不能使用的场景" class="headerlink" title="不能使用的场景"></a>不能使用的场景</h4><ol>
<li>定义对象上的方法</li>
</ol>
<ul>
<li>Object</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const calculate = &#123;</span><br><span class="line">  array: [1,2,3],</span><br><span class="line">  sum: () =&gt; &#123;</span><br><span class="line">    console.log(this === window) // true</span><br><span class="line">    return this.array.reduce((result, item) =&gt; result + item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">calculate.sum();</span><br><span class="line">当调用calculate对象上的方法sum()时，上下文仍然是window。是因为箭头函数按词法作用域将上下温暖绑定到window对象。</span><br><span class="line"></span><br><span class="line">————————————————————————</span><br><span class="line">const calculate = &#123;</span><br><span class="line">  array: [1,2,3],</span><br><span class="line">  sum: function() &#123;</span><br><span class="line">    console.log(this === calculate) // true</span><br><span class="line">    return this.array.reduce((result, item) =&gt; result + item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">calculate.sum();</span><br></pre></td></tr></table></figure>
<ul>
<li>Object prototype</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function MyCat(name) &#123;</span><br><span class="line">  this.catName = name;</span><br><span class="line">&#125;</span><br><span class="line">// 使用箭头函数来定义sayCatName方法，this指向window</span><br><span class="line">MyCat.prototype.sayCatName = () =&gt; &#123;</span><br><span class="line">  console.log(this === window);</span><br><span class="line">  return this.catName;</span><br><span class="line">&#125;</span><br><span class="line">// 正确的方式</span><br><span class="line">MyCat.prototype.sayCatName = function()&#123;</span><br><span class="line">  console.log(this === window);</span><br><span class="line">  return this.catName;</span><br><span class="line">&#125;</span><br><span class="line">const cat = new MyCat(&apos;Mew&apos;);</span><br><span class="line">cat.sayCatName(); // undefined</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2. 动态上下文的回调函数  </span><br><span class="line">事件监听器附加到DOM元素,在全局上下文中，this指向window，不会指向当前调用元素。</span><br></pre></td></tr></table></figure>
<p>const button = document.getElementById(‘btn’);<br>button.addEventListener(‘click’, () =&gt; {<br>  console.log(this === window)<br>  this.innerHTML = ‘Clicked button’;<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 调用构造函数  </span><br><span class="line">&gt; 箭头函数不能用作构造函数。Javasxript通过抛出异常隐士阻止这样做。this是来自自封闭上下文的设置，而不是新创建的对象。</span><br></pre></td></tr></table></figure>
<p>const Message = (text) =&gt; {<br>  this.text = text;<br>}<br>const helloMessage = new Message(‘Hello’); // Throws TypeError<br><code>`</code></p>
<blockquote>
<p>正确使用箭头函数时，会使用.bind()或试图捕获上下文的地方变得简单。当需要动态上下文时，不能使用箭头函数： 定义方法，使用构造函数创建对象，在处理事件时从this获取目标。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/15/ES6语法笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/ES6语法笔记/" itemprop="url">ES6语法笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T09:48:37+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h3><blockquote>
<p>装饰器修饰类函数的时候，可以接受三个参数。第一个是要修饰的对象，第二个是修饰的属性名，第三个是属性描述符。而用装饰器修饰类的时候，只接受一个参数target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 修饰函数</span><br><span class="line">class A &#123;</span><br><span class="line">    @sayB</span><br><span class="line">    sayA() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function sayB(target, name, descriptor) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 修饰类</span><br><span class="line">@sayA</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function sayA(target)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 修饰类加参数</span><br><span class="line">@sayA(&#123; name: &apos;A&apos; &#125;)</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function sayA(obj) &#123;</span><br><span class="line">    return (target) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy用于修改某些操作的默认行为，可以理解为在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，提供了这种机制就可以对外界的访问进行过滤和改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get: function(target, key, receiver) &#123;</span><br><span class="line">        console.log(`getting $&#123;key&#125;!`);</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(target, key, value, receiver) &#123;</span><br><span class="line">        console.log(`setting $&#123;key&#125;!`)</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">上面代码对一个空对象架设了一层拦截， 重新定义了属性的get和set行为</span><br><span class="line">obj.count = 1</span><br><span class="line">// setting count!</span><br><span class="line">++obj.count</span><br><span class="line">// getting count!</span><br><span class="line">// setting count!</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>get(target, propKey, receiver)  get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象，属性名和proxy实例本身（严格地说，是操作行为所针对的对象）</p>
</li>
<li><p>set(target, propKey, value, receiver)<br>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和proxy实例本身</p>
</li>
<li><p>has(target, propKey)</p>
</li>
<li><p>deleteProperty(target, propKey)  deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
</li>
<li><p>ownKeys(target)<br>ownKeys方法好用来拦截对象自身属性的操作。具体来说，拦截一下操作。</p>
</li>
</ul>
<ol>
<li>Object.getOwnPropertyNames()</li>
<li>Object.getOwnPropertySymbols()</li>
<li>Object.keys()</li>
<li>for…in循环</li>
</ol>
<ul>
<li><p>getOwnPropertyDescriptor(target, propKey)<br>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()</p>
</li>
<li><p>defineProperty(target, propKey, propDesc)<br>defineProperty方法拦截了Object.defineProperty操作</p>
</li>
<li><p>preventExtensions(target)<br>priventExtensions方法拦截Object.preventExtensions(),该方法必须返回一个布尔值，否则会被自动转为布尔值</p>
</li>
<li><p>isExtensible(target)<br>isExtensible方法拦截Object.isExtensible<br>操作</p>
</li>
<li><p>getPrototypeOf<br>getPrototypeOf方法用来拦截获取对象原型</p>
</li>
<li><p>setPrototypeOf(target, proto)<br>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</p>
</li>
<li><p>apply(target, object, args)<br>apply方法拦截函数的调用，可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组</p>
</li>
<li><p>construct(target, args)<br>construct用于拦截new命令</p>
</li>
</ul>
<h4 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h4><p>Proxy。revocable方法返回一个可取消的Proxy实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;&#125;</span><br><span class="line">let handler = &#123;&#125;;</span><br><span class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</span><br><span class="line">proxy.foo = 123;</span><br><span class="line">proxy,foo // 123</span><br><span class="line">revoke();</span><br><span class="line">proxy.foo // TypeError: Revoked</span><br></pre></td></tr></table></figure></p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>Reflect对象和Proxy对象一样，其设计目的</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty）放到Reflect对象上。也就是说可以从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false</li>
<li>让Object操作都变成函数行为。某些Object是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj,name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/nginx项目实战小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/nginx项目实战小结/" itemprop="url">nginx项目使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T09:48:09+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><h4 id="nginx-cookie丢失问题"><a href="#nginx-cookie丢失问题" class="headerlink" title="nginx cookie丢失问题"></a>nginx cookie丢失问题</h4><p>系统通过域名解析经过阿里云的SLB解析进入内网通过nginx的转发到后端各服务，因为后端服务是标准的oauth2.0,请求过程中需要验证是否存在cookie，没有登录则重定向到登录页面，通过nginx的proxy_pass代理到后端服务时，发现cookie丢失，每次登录完之后又循环重定向到登录页面。通过配置proxy_cookie_path属性，同时登录成功后刷新页面会导致404，需要配置<em>try_files $uri /index.html</em> ，（此属性的作用按顺序检查文件是否存在，返回第一个找到的文件或文件夹(结尾加斜线表示为文件夹)，如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数）。<br><img src="/images/2019-7/2019-07-03.jpg" alt="nginx系统架构图"><br><a href="https://blog.csdn.net/we_shell/article/details/45153885" target="_blank" rel="noopener">参考文档</a></p>
<h4 id="nginx-websocket代理"><a href="#nginx-websocket代理" class="headerlink" title="nginx websocket代理"></a>nginx websocket代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection $connection_upgrade;</span><br><span class="line">这里的关键部分在于HTTP请求中多了如下头部：</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p><img src="/images/2019-7/2019-07-03.1.jpg" alt="nginx最终配置图"><br><a href="https://www.xncoding.com/2018/03/12/fullstack/nginx-websocket.html" target="_blank" rel="noopener">参考文档1</a><br><a href="https://www.hi-linux.com/posts/42176.html" target="_blank" rel="noopener">参考文档2</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/javascript设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/javascript设计模式/" itemprop="url">javascript设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T09:48:37+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="给函数添加方法"><a href="#给函数添加方法" class="headerlink" title="给函数添加方法"></a>给函数添加方法</h3><ul>
<li><p>通过给Function构造函数的原型添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.addMethod = function(name, fn) &#123;</span><br><span class="line">  this[name] = fn;</span><br><span class="line">  return this; // 方便链式调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">const methods = function() &#123;&#125;; &lt;=&gt; const methods = new Function();</span><br><span class="line">methods.addMethod(&apos;checkName&apos;, function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;).addMethod(&apos;checkEmail&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">methods.checkName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>习惯类调用而通过new来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.addMethod = function(name, fn) &#123;</span><br><span class="line">  this.prototype[name] = fn;</span><br><span class="line">  return this; // 方便链式调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">const Methods = function() &#123;&#125;;</span><br><span class="line">Methods.addMethod(&apos;checkName&apos;, function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;).addMethod(&apos;checkEmail&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">const m = new Methods();</span><br><span class="line">m.checkName();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="this创建对象"><a href="#this创建对象" class="headerlink" title="this创建对象"></a>this创建对象</h3><p>通过this将方法定义在函数的内部，每一次通过new关键字创建对象的时候，新创建的对象都会类的this的属性上进行复制，新创建的对象都会有自己的一套方法，然后有时候这么做或造成内存不必要的消耗，通过在函数的原型上添加可以共用的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var checkObj = function () &#123;</span><br><span class="line">  this.checkName: function() &#123;&#125;,</span><br><span class="line">  this.checkEmail: function() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------原型公用-----------</span><br><span class="line"></span><br><span class="line">var CheckObj = function() &#123;&#125;</span><br><span class="line">CheckObj.prototype = function() &#123;</span><br><span class="line">  checkName: function()&#123;&#125;,</span><br><span class="line">  checkEmail: function()&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>通过点语法定义的属性以及方法被成为类的静态公有属性和类的静态共有方法，而通过prototype创建的属性或者方法可以通过this访问到（实例对象通过<em>proto</em>指向类的原型对象），将prototype对象中的属性和方法称为共有属性和共有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 类静态公有属性（对象不能访问）</span><br><span class="line">Book.isChinese = true;</span><br><span class="line">// 类静态公有方法（对象不能访问）</span><br><span class="line">Book.resetTime = function() &#123;&#125;</span><br><span class="line">Book.prototype = &#123;</span><br><span class="line">  // 公有属性</span><br><span class="line">  isJSBook: false,</span><br><span class="line">  // 公有方法</span><br><span class="line">  display: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line">var b = new Book(11, &apos;javascript&apos;, 50)</span><br><span class="line">console.log(b.isChinese)  // undefined</span><br><span class="line">console.log(b.isJSBook) // false</span><br></pre></td></tr></table></figure>
<h3 id="继承原理分析"><a href="#继承原理分析" class="headerlink" title="继承原理分析"></a>继承原理分析</h3><p>继承的方式</p>
<ol>
<li>类式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明父类</span><br><span class="line">function SuperClass() &#123;</span><br><span class="line">  this.superValue = true;</span><br><span class="line">&#125;</span><br><span class="line">// 为父类添加公有属性和方法</span><br><span class="line">SuperClass.prototype.getSuperValue = function() &#123;</span><br><span class="line">  return this.superValue</span><br><span class="line">&#125;</span><br><span class="line">// 声明子类</span><br><span class="line">function SubClass() &#123;</span><br><span class="line">  this.subValue = false;</span><br><span class="line">&#125;</span><br><span class="line">// 继承父类</span><br><span class="line">SubClass.prototype = new SuperClass</span><br><span class="line">// 为子类添加共有方法</span><br><span class="line">SubClass.prototype.getSubValue = function() &#123;</span><br><span class="line">  return this.subValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析： 继承的核心代码，将父类的实例赋值给子类的原型。<code>SubClass.prototype = new SuperClass()</code>。<br>  类的原型对象的作用是为类的原型添加共有方法，但类不能直接访问这些属性和方法，必须要通过原型prototype来访问。实例化父类的时候，新创建的对象不仅可以访问父类原型上的属性和方法，同样也可以访问父类构造函数中复制的属性和方法，而且将原型<em>proto</em>指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法。我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。</p>
<ol start="2">
<li>构造函数继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(id) &#123;</span><br><span class="line">  this.books = [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class="line">  this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.showBooks = function() &#123;</span><br><span class="line">  return this.books;</span><br><span class="line">&#125;</span><br><span class="line">function SubClass() &#123;</span><br><span class="line">  // 继承父类</span><br><span class="line">  SuperClass.call(this,id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubClass(10);</span><br><span class="line">var instance2 = new SubClass(11);</span><br><span class="line">instance1.push(&apos;设计模式&apos;)</span><br><span class="line">console.log(instance1.books) // [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]</span><br><span class="line">console.log(instance1.id) // 10</span><br><span class="line">console.log(instance2.books) // [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class="line">console.log(instance2.id) // 11</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析：<code>SuperClass.call(this,id)</code>是构造函数的精华，call方法改变了函数的作用环境，在子类中superClass调用这个方法就是将子类中的变量在父类执行一遍，由于父类是给this绑定属性的，因此子类就继承了父类的共有属性。</p>
<blockquote>
<p>由于类型的继承没有涉及原型prototype，所以父类的原型方法不会被子类继承。<strong>子类不是父类的实例，子类的原型是父类的实例</strong></p>
</blockquote>
<ol start="3">
<li>组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.books = [&apos;html&apos;, &apos;css&apos;, &apos;js&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getName = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">  // 构造函数式继承父类name属性</span><br><span class="line">  SuperClass.call(this, time);</span><br><span class="line">  this.time = time;</span><br><span class="line">&#125;</span><br><span class="line">// 类是继承 子类原型继承父类</span><br><span class="line">Subclass.prototype = new SuperClass();</span><br><span class="line">Subclass.prototype.getTime = function ()&#123;</span><br><span class="line">  console.log(this.time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不足之处： 父类构造函数调用了两次</p>
<ol start="4">
<li>原型式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function inheritObject(o) &#123;</span><br><span class="line">  // 声明一个过渡函数对象</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析： 其本质是对类式继承的一种封装，只不过由于F过度类的构造函数中无内容所以开销比较小，但是类式继承的缺点仍然存在(父类对象中的值类型的属性被复制，引用类型的属性被共用)</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明基对象</span><br><span class="line">var book = &#123;</span><br><span class="line">  name: &apos;js book&apos;,</span><br><span class="line">  alikeBook: [&apos;css book&apos;, &apos;html, book&apos;],</span><br><span class="line">&#125;</span><br><span class="line">function createBook(obj) &#123;</span><br><span class="line">  var o = new inheritObject(obj);</span><br><span class="line">  // 拓展新对象</span><br><span class="line">  o.getName = function() &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析： 对原型继承的二次封装，对继承的对象进行了拓展，这样创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>
<ol start="6">
<li>寄生组合式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subClass, superClass)&#123;</span><br><span class="line">  // 复制一份父类的原型副本保存在变量中</span><br><span class="line">  var p = inheritObject(superClass.prototype)</span><br><span class="line">  // 修正因为重写子类原型导致子类的constrcutor属性被修改</span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  // 设置子类的原型</span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析： 在构造函数继承中调用了父类的构造函数，通过原型继承获得父类的原型对象的一个副本，直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的constructor指向的不是subClass子类对象，因此对寄生式继承中要复制对象p做一次增强，修复其constructor属性指向不正确的问题，最后将得到的复制对象p复制给子类的原型，这样子类的原型就继承了父类的原型并且没有再次执行父类的构造函数。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>简单工厂模式</li>
</ul>
<p>工厂方法模式本意是将实际创建对象工作推迟到子类当中。（js中可以理解为在类的原型上增加方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createBook(name, time, type) &#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.time = time;</span><br><span class="line">  o.type = type;</span><br><span class="line">  o.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解析：工厂模式可以通过实例化对象创建或者创建一个新对象然后包装增强其属性和功能来实现，都是类似与寄生式继承。<strong>通过简单工厂来创建一个对象，可以让这些对象共有一些资源而又私有一些资源</strong>。</p>
<ul>
<li><p>安全的工厂模式<br>在构造函数开始时先判断当前对象this是不是指向当前类（instanceOf 判断），如果是则通过new关键字创建对象，如果不是则在全局作用域window中执行。<br><strong>工厂模式主要是为了创建对象实例或者类簇</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Factory = function(type, content) &#123;</span><br><span class="line">  if (this instanceOf Factory) &#123;</span><br><span class="line">    return new this[type](content)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Factory(type, content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">  Java: function(content) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  Javascript: function(content) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  Php: function(content) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型模式<br>为了提高技能，每当创建基类时，对于每次创建的一些简单而又差异化的属性放在构造函数中，将一些消耗资源的方法放在基类的原型中。<br>原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中/、。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 图片轮播基类</span><br><span class="line">var LoopImages = function(imgArr, container) &#123;</span><br><span class="line">  this.imagesArray = imgArr;</span><br><span class="line">  this.container = container;</span><br><span class="line">&#125;</span><br><span class="line">LoopImages.prototype = &#123;</span><br><span class="line">  createImage: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  changeImage: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上下滑动切换类</span><br><span class="line">var SlideLoopImg = function(imgArr, container) &#123;</span><br><span class="line">  LoopImages.call(this, imgArr, container);</span><br><span class="line">&#125;</span><br><span class="line">SlideLoopImg.prototype = new LoopImages();</span><br><span class="line">SlideLoopImg.prototype.changeImg = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式</p>
</li>
</ul>
<p>只允许实例化一次的对象类。区别是主要加上命名空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Ming = &#123;</span><br><span class="line">  g: function(id) &#123;</span><br><span class="line">    return document.getElementById(id)</span><br><span class="line">  &#125;,</span><br><span class="line">  css: function(id, key, value) &#123;</span><br><span class="line">    g(id).style[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>观察者模式<br>观察者模式的作用是为了解决<strong>类或者对象之间的耦合，解耦两个相互依赖的对象</strong>，使其依赖于观察者的消息机制。这样对于任意一个订阅者来说，其他订阅者对象的改变不会影响到自身。对于每一个订阅者来说，其自身既可以是消息的发出者也可以是消息的执行者，这都依赖于调用观察者对象的三种方法（订阅消息、注销消息、发送消息）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var Observer = (function()&#123;</span><br><span class="line">  var _messages = &#123;&#125;;</span><br><span class="line">  return &#123;</span><br><span class="line">    regist: function(type, fn) &#123;</span><br><span class="line">      if (typeOf _message[type] === &apos;undefined&apos;) &#123;</span><br><span class="line">        // 如果此消息不存在，则创建一个该消息类型</span><br><span class="line">        _message[type] = fn;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 将动作方法推入该消息对应的动作执行序列中</span><br><span class="line">        _message[type].push(fn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(type, args) &#123;</span><br><span class="line">      if (!message[type]) return;</span><br><span class="line">      var events = &#123;</span><br><span class="line">        type,</span><br><span class="line">        args: args || &#123;&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      len = _message[type].length;</span><br><span class="line">      let i;</span><br><span class="line">      for(; i&lt; len; i++) &#123;</span><br><span class="line">        // 依次执行注册的消息对应的动作序列</span><br><span class="line">        _message[type][i].call(this, events);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: function(type, fn) &#123;</span><br><span class="line">      if (_message[type] instanceOf Array) &#123;</span><br><span class="line">        let i = _message[type].length - 1;</span><br><span class="line">        // 如果存在该动作则在消息队列中移除相应动作</span><br><span class="line">        for(;i &gt; 0;i--) &#123;</span><br><span class="line">          _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<ul>
<li>状态模式<br>状态模式既是解决程序中臃肿的分支判断语句问题，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有分支。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var MarryState = function() &#123;</span><br><span class="line">  var _currentState = &#123;&#125;,</span><br><span class="line">      states = &#123;</span><br><span class="line">        jump: function() &#123;</span><br><span class="line">          console.log(&apos;jump&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        move: function() &#123;</span><br><span class="line">          console.log(&apos;move&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        shoot: function() &#123;</span><br><span class="line">          console.log(&apos;shoot&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">        squat: function() &#123;</span><br><span class="line">          console.log(&apos;squat&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  var Action = function()&#123;</span><br><span class="line">    changeState: function() &#123;</span><br><span class="line">      var arg = arguments;</span><br><span class="line">      _currentState = &#123;&#125;;</span><br><span class="line">      if (arg.length) &#123;</span><br><span class="line">        for(var i=0,len = arg.length;i &lt; len; i++) &#123;</span><br><span class="line">          _currentState[arg[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    goes: function() &#123;</span><br><span class="line">      console.log(&apos;触发一次动作&apos;)；</span><br><span class="line">      for(var i in _currentState) &#123;</span><br><span class="line">        states[i]&amp;&amp;states[i]()</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    change: Action.changeState,</span><br><span class="line">    goes: Action.goes,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">MarryState()</span><br><span class="line">  .change(&apos;jump&apos;, &apos;shoot&apos;)</span><br><span class="line">  .goes()</span><br><span class="line">  .change(&apos;shoot&apos;)</span><br><span class="line">或者</span><br><span class="line">var marry = new MarryState();</span><br><span class="line">marry.change(&apos;jump&apos;, &apos;shoot&apos;)</span><br><span class="line">  .goes()</span><br><span class="line">  .change(&apos;shoot&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>惰性模式</li>
</ul>
<p>惰性模式：减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">A.on = function(dom, type, fn) &#123;</span><br><span class="line">  if (dom.addEventListener) &#123;</span><br><span class="line">    dom.addEventListener(type, fn, false);</span><br><span class="line">  &#125; else if (dom.attachEvent) &#123;</span><br><span class="line">    dom.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    dom[&apos;on&apos; + type] = fn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载即执行的优化(页面加载时优化)</span><br><span class="line">A.on= function(dom, type, fn) &#123;</span><br><span class="line">  if (dom.addEventListener) &#123;</span><br><span class="line">    return function(dom, type, fn) &#123;</span><br><span class="line">      dom.addEventListener(type, fn, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (dom.attachEvent) &#123;</span><br><span class="line">    return function(dom, type, fn) &#123;</span><br><span class="line">      dom.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function(dom, type, fn) &#123;</span><br><span class="line">      dom[&apos;on&apos; + type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// 惰性执行(第一次绑定时重新定义方法，第一次执行时耗费性能)</span><br><span class="line">A.on = function(dom, type, fn) &#123;</span><br><span class="line">  if (dom.addEventListener) &#123;</span><br><span class="line">    A.on = function(dom, type, fn) &#123;</span><br><span class="line">      dom.addEventListener(type, fn, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (dom.attachEvent) &#123;</span><br><span class="line">    A.on = function(dom, type, fn) &#123;</span><br><span class="line">      dom.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    A.on = function(dom, type, fn) &#123;</span><br><span class="line">      dom[&apos;on&apos; + type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  A.on(dom, type, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/typescript入门实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/typescript入门实战/" itemprop="url">typescript入门实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T09:48:37+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Hello(&#123; name, enthusiasmLevel = 1 &#125;: Props) &#123;</span><br><span class="line">  if (enthusiasmLevel &lt;= 0) &#123;</span><br><span class="line">    throw new Error(&apos;You could be a little more enthusiastic. :D&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;hello&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;greeting&quot;&gt;</span><br><span class="line">        Hello &#123;name + getExclamationMarks(enthusiasmLevel)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种是通过无状态组件（stateless function component （SFC）））的形式引入，但是我们更常用的是通过类形式引入一个组件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component&lt;Props, object&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, enthusiasmLevel = 1 &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    if (enthusiasmLevel &lt;= 0) &#123;</span><br><span class="line">      throw new Error(&apos;You could be a little more enthusiastic. :D&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;hello&quot;&gt;</span><br><span class="line">        &lt;div className=&quot;greeting&quot;&gt;</span><br><span class="line">          Hello &#123;name + getExclamationMarks(enthusiasmLevel)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">我们只需要考虑到props的类型，所以通过泛型接口的形式定义为React.Component&lt;Props, object&gt;,其中Props是我们类中的this.props,object是类中的this.state,此处我们只对props进行了校验。</span><br></pre></td></tr></table></figure></p>
<p>createStore<storestate>函数的泛型就收四个参数，按照教程提示就会报相应的错误，应该修正为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore&lt;StoreState, any, &#123;&#125;, &#123;&#125;&gt;(enthusiasm, &#123;</span><br><span class="line">  enthusiasmLevel: 1,</span><br><span class="line">  languageName: &apos;TypeScript&apos;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></storestate></p>
<ul>
<li>withRouter的作用  </li>
</ul>
<p>把不是通过路由切换过来的组件中，将react-router的history、location、match三个对象传入props对象上。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用方式</span><br><span class="line">***</span><br><span class="line">class Test extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(Test)</span><br></pre></td></tr></table></figure>
<p>问题： /Users/kirin/node_modules/@types/react/index.d.ts<br>(2312,14): Duplicate identifier ‘LibraryManagedAttributes’.</p>
<p>解决：<em>“skipLibCheck”</em>: true此方法不能从根本上解决问题。</p>
<p>问题：Parsing error: The keyword ‘import’ is reserved eslint<br>解决：项目根目录加入.eslintrc.json文件，并加入以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">    &quot;jsx&quot;: true,</span><br><span class="line">    &quot;modules&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">替换为</span><br><span class="line">&quot;parserOptions&quot;: &#123;</span><br><span class="line">    &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">        &quot;jsx&quot;: true,</span><br><span class="line">        &quot;modules&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者加入以下配置，并安装相关依赖</span><br><span class="line">&quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line"></span><br><span class="line">- npm install -g eslint@1.x.x babel-eslint@4.x.x</span><br><span class="line">- npm install -g eslint-plugin-react@3.x.x</span><br></pre></td></tr></table></figure></p>
<p>问题： The class method ‘render’ must be marked either ‘private’, ‘public’, or ‘protected’<br>解决： 此问题主要是由于tslint的规范，可以关闭此校验，通过在tslint.json中配置<code>member-access: false</code>,<a href="https://palantir.github.io/tslint/rules/member-access/" target="_blank" rel="noopener">详情可参考</a></p>
<p>问题： Class name must be in pascal case tslint<br>解决： 没找到合适的解决方案，最后只能取消eslint中extends中的配置，将tslint.json文件中<code>extends: []</code></p>
<p>问题： Module ‘“/Users/kirin/study/front/ts-study/node_modules/@types/react/index”‘ has no default export.<br>解决： 添加<code>&quot;allowSyntheticDefaultImports&quot;: true</code>配置到tsconfig.json,或者改成<code>import * as React from &#39;react&#39;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/react设计模式与最佳实践笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/react设计模式与最佳实践笔记/" itemprop="url">react设计模式与最佳实践笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T09:27:19+08:00">
                2019-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务端渲染的乐趣与益处"><a href="#服务端渲染的乐趣与益处" class="headerlink" title="服务端渲染的乐趣与益处"></a>服务端渲染的乐趣与益处</h2><ol>
<li>通用引用概念：这类应用往往通过服务端返回带有script标签的空html页面进行加载。加载完毕后，应用会操作浏览器中的DOM来显示UI，并与用户交互</li>
<li>react在服务端渲染相同组件的特性称为服务端渲染（SSR）</li>
<li>通用应用是指应用的代码可以同时用于服务端和客户端</li>
<li><p>使用服务端渲染的原因：</p>
<ul>
<li>SEO，如果为主流搜索引擎的爬虫提供空壳HTML，那么将无法从中解析出任何有意义的信息</li>
<li>通用代码库，方便交流</li>
<li>性能更强</li>
<li></li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/typescript学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/typescript学习笔记/" itemprop="url">typescript学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:37+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ul>
<li>布尔值 </li>
<li>数字（number） </li>
<li>字符串（string） </li>
</ul>
<ul>
<li><p>数组</p>
<ol>
<li>在元素类型后面接上[],表示由此元素组成一个数组<br><code>let list:number[] = [1, 2, 3];</code></li>
<li>使用数组泛型<br><code>let list:Array\&lt;number&gt; = [1, 2, 3]</code></li>
</ol>
</li>
<li><p>元组  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x: [string: number];</span><br><span class="line">x = [&apos;hello&apos;, 10];</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举<br><code>enmu Color { Red, Green, Blue}
let c: Color = Color.Green</code></p>
</li>
<li>Any 类型检查器不对这些值进行检查让他们直接通过编译器的检查<br><code>let notSure: any = 4;</code></li>
<li>void 表示没有任何类型，当一个函数没有返回值时。</li>
<li>Null和 Undefined</li>
<li><p>Never 类型表示的是那些永不存在的值的类型。例如never类型时那些总是会抛出异常或根本没有返回值的函数表达式或箭头函数表达式的返回值类型  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推断的返回值类型为never</span><br><span class="line">function fail() &#123;</span><br><span class="line">    return error(&quot;Something failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>object表示非原始类型，也就是除number，string， boolean， symbol， null或undefined之外的类型</p>
</li>
<li>类型断言(好比l类型转换，但是不进行特殊的数据检查h和解构)  </li>
</ul>
<ol>
<li>“尖括号语法”<br><code>let strLength: number = (\&lt;string\&gt;someValue).length</code>  </li>
<li>as语法<br><code>let strLength: number = (someValue as string).length;</code></li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>基本类型  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 可选属性  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">interface LabelledValue &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>只读属性  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let p1: Point = &#123; x: 10, y: 20&#125;;</span><br><span class="line">p1.x = 5 //error,一旦赋值就不可改变</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型<br>为了使用接口表示函数类型，我们给接口定义一个调用签名。只有参数列表和返回值类型的函数定义  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可索引的类型<br>可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span><br><span class="line"></span><br><span class="line">let myStr: string = myArray[0];</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口继承类<br>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。<strong>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：“Image”类型缺少“state”属性。</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>类的继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: number = 0) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 45) &#123;</span><br><span class="line">        console.log(&quot;Galloping...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用extends关键字创建了Animal的两个子类Horse和Snake，派生类包含类一个构造函数，必须调用super(),它会执行基类的构造函数。而且，<strong>在构造函数里访问this属性之前，我们一定要调用super()</strong></p>
<ul>
<li>公共，私有与受保护的修饰符</li>
</ul>
<ol>
<li>类默认伟为public，我们可以自由的访问程序里定义的成员。</li>
<li>private：不能在它的类的外部使用。</li>
<li>protected：protected成员在派生类中仍然可以访问。</li>
</ol>
<ul>
<li>private跟protected的区别</li>
</ul>
<ol>
<li>private： 私有的。在类中如果声明一个属性为私有，则表示这个属性仅仅属于这个类。仅仅能在这个类中进行这个属性的访问，在<strong>子类和类的实现</strong>的对象中都不能访问。在子类可以通过调用这个属性的方法来间接使用这个属性。</li>
<li>protected: 被保护的，针对对象。因为一个类可以化身为好多对象。对于这些对象共有的属性不应该让对象有访问和修改的权力。对于protected声明的属性可以在子类中访问它，<strong>不能在实现对象中访问</strong>。对于protected声明的构造方法，<strong>该类只能被继承不能被实现</strong></li>
</ol>
<ul>
<li>抽象类<br>抽象类作为其他派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&apos;roaming the earch...&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</strong> 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>书写完整函数类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number =</span><br><span class="line">    function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于返回值，在函数和返回值类型之前使用( =&gt; )符号，使之清晰明了。<strong>返回值类型是函数类型的必要部分，如果没有返回任何值，你也必须指定返回值类型为void而不能留空</strong></p>
<ul>
<li><p>可选参数和默认参数<br>可选参数通过在参数名旁使用？实现，<strong>可选参数必须跟在必须参数后面</strong></p>
</li>
<li><p>this和箭头函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    createCardPicker: function() &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line"></span><br><span class="line">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。解决方案是将return一个箭头函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KIRIN</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KIRIN</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
