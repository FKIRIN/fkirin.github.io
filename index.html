<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KIRIN&#39;S blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KIRIN&#39;S blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KIRIN&#39;S blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>KIRIN'S blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KIRIN'S blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/javascript设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/javascript设计模式/" itemprop="url">javascript设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T09:48:37+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="给函数添加方法"><a href="#给函数添加方法" class="headerlink" title="给函数添加方法"></a>给函数添加方法</h3><ul>
<li><p>通过给Function构造函数的原型添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.addMethod = function(name, fn) &#123;</span><br><span class="line">  this[name] = fn;</span><br><span class="line">  return this; // 方便链式调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">const methods = function() &#123;&#125;; &lt;=&gt; const methods = new Function();</span><br><span class="line">methods.addMethod(&apos;checkName&apos;, function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;).addMethod(&apos;checkEmail&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">methods.checkName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>习惯类调用而通过new来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.addMethod = function(name, fn) &#123;</span><br><span class="line">  this.prototype[name] = fn;</span><br><span class="line">  return this; // 方便链式调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">const Methods = function() &#123;&#125;;</span><br><span class="line">Methods.addMethod(&apos;checkName&apos;, function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;).addMethod(&apos;checkEmail&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">const m = new Methods();</span><br><span class="line">m.checkName();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="this创建对象"><a href="#this创建对象" class="headerlink" title="this创建对象"></a>this创建对象</h3><p>通过this将方法定义在函数的内部，每一次通过new关键字创建对象的时候，新创建的对象都会类的this的属性上进行复制，新创建的对象都会有自己的一套方法，然后有时候这么做或造成内存不必要的消耗，通过在函数的原型上添加可以共用的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var checkObj = function () &#123;</span><br><span class="line">  this.checkName: function() &#123;&#125;,</span><br><span class="line">  this.checkEmail: function() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------原型公用-----------</span><br><span class="line"></span><br><span class="line">var CheckObj = function() &#123;&#125;</span><br><span class="line">CheckObj.prototype = function() &#123;</span><br><span class="line">  checkName: function()&#123;&#125;,</span><br><span class="line">  checkEmail: function()&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>通过点语法定义的属性以及方法被成为类的静态公有属性和类的静态共有方法，而通过prototype创建的属性或者方法可以通过this访问到（实例对象通过<em>proto</em>指向类的原型对象），将prototype对象中的属性和方法称为共有属性和共有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 类静态公有属性（对象不能访问）</span><br><span class="line">Book.isChinese = true;</span><br><span class="line">// 类静态公有方法（对象不能访问）</span><br><span class="line">Book.resetTime = function() &#123;&#125;</span><br><span class="line">Book.prototype = &#123;</span><br><span class="line">  // 公有属性</span><br><span class="line">  isJSBook: false,</span><br><span class="line">  // 公有方法</span><br><span class="line">  display: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line">var b = new Book(11, &apos;javascript&apos;, 50)</span><br><span class="line">console.log(b.isChinese)  // undefined</span><br><span class="line">console.log(b.isJSBook) // false</span><br></pre></td></tr></table></figure>
<h3 id="继承原理分析"><a href="#继承原理分析" class="headerlink" title="继承原理分析"></a>继承原理分析</h3><p>继承的方式</p>
<ol>
<li>类式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明父类</span><br><span class="line">function SuperClass() &#123;</span><br><span class="line">  this.superValue = true;</span><br><span class="line">&#125;</span><br><span class="line">// 为父类添加公有属性和方法</span><br><span class="line">SuperClass.prototype.getSuperValue = function() &#123;</span><br><span class="line">  return this.superValue</span><br><span class="line">&#125;</span><br><span class="line">// 声明子类</span><br><span class="line">function SubClass() &#123;</span><br><span class="line">  this.subValue = false;</span><br><span class="line">&#125;</span><br><span class="line">// 继承父类</span><br><span class="line">SubClass.prototype = new SuperClass</span><br><span class="line">// 为子类添加共有方法</span><br><span class="line">SubClass.prototype.getSubValue = function() &#123;</span><br><span class="line">  return this.subValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析： 继承的核心代码，将父类的实例赋值给子类的原型。<code>SubClass.prototype = new SuperClass()</code>。<br>  类的原型对象的作用是为类的原型添加共有方法，但类不能直接访问这些属性和方法，必须要通过原型prototype来访问。实例化父类的时候，新创建的对象不仅可以访问父类原型上的属性和方法，同样也可以访问父类构造函数中复制的属性和方法，而且将原型<em>proto</em>指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法。我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。</p>
<ol start="2">
<li>构造函数继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(id) &#123;</span><br><span class="line">  this.books = [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class="line">  this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.showBooks = function() &#123;</span><br><span class="line">  return this.books;</span><br><span class="line">&#125;</span><br><span class="line">function SubClass() &#123;</span><br><span class="line">  // 继承父类</span><br><span class="line">  SuperClass.call(this,id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubClass(10);</span><br><span class="line">var instance2 = new SubClass(11);</span><br><span class="line">instance1.push(&apos;设计模式&apos;)</span><br><span class="line">console.log(instance1.books) // [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;, &apos;设计模式&apos;]</span><br><span class="line">console.log(instance1.id) // 10</span><br><span class="line">console.log(instance2.books) // [&apos;JS&apos;, &apos;html&apos;, &apos;css&apos;]</span><br><span class="line">console.log(instance2.id) // 11</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析：<code>SuperClass.call(this,id)</code>是构造函数的精华，call方法改变了函数的作用环境，在子类中superClass调用这个方法就是将子类中的变量在父类执行一遍，由于父类是给this绑定属性的，因此子类就继承了父类的共有属性。由于类型的继承没有涉及原型prototype，所以父类的原型方法不会被子类继承。<strong>子类不是父类的实例，子类的原型是父类的实例</strong></p>
<ol start="3">
<li>组合式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.books = [&apos;html&apos;, &apos;css&apos;, &apos;js&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getName = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">  // 构造函数式继承父类name属性</span><br><span class="line">  SuperClass.call(this, time);</span><br><span class="line">  this.time = time;</span><br><span class="line">&#125;</span><br><span class="line">// 类是继承 子类原型继承父类</span><br><span class="line">Subclass.prototype = new SuperClass();</span><br><span class="line">Subclass.prototype.getTime = function ()&#123;</span><br><span class="line">  console.log(this.time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不足之处： 父类构造函数调用了两次</p>
<ol start="4">
<li>原型式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function inheritObject(o) &#123;</span><br><span class="line">  // 声明一个过渡函数对象</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析： 其本质是对类式继承的一种封装，只不过由于F过度类的构造函数中无内容所以开销比较小，但是类式继承的缺点仍然存在(父类对象中的值类型的属性被复制，引用类型的属性被共用)</p>
<ol start="5">
<li>寄生式继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明基对象</span><br><span class="line">var book = &#123;</span><br><span class="line">  name: &apos;js book&apos;,</span><br><span class="line">  alikeBook: [&apos;css book&apos;, &apos;html, book&apos;],</span><br><span class="line">&#125;</span><br><span class="line">function createBook(obj) &#123;</span><br><span class="line">  var o = new inheritObject(obj);</span><br><span class="line">  // 拓展新对象</span><br><span class="line">  o.getName = function() &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析： 对原型继承的二次封装，对继承的对象进行了拓展，这样创建的对象不仅仅有父类中的属性和方法而且还添加了新的属性和方法。</p>
<ol start="6">
<li>寄生组合式继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subClass, superClass)&#123;</span><br><span class="line">  // 复制一份父类的原型副本保存在变量中</span><br><span class="line">  var p = inheritObject(superClass.prototype)</span><br><span class="line">  // 修正因为重写子类原型导致子类的constrcutor属性被修改</span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  // 设置子类的原型</span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解析： 在构造函数继承中调用了父类的构造函数，通过原型继承获得父类的原型对象的一个副本，直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的constructor指向的不是subClass子类对象，因此对寄生式继承中要复制对象p做一次增强，修复其constructor属性指向不正确的问题，最后将得到的复制对象p复制给子类的原型，这样子类的原型就继承了父类的原型并且没有再次执行父类的构造函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/typescript入门实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/typescript入门实战/" itemprop="url">typescript入门实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T09:48:37+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Hello(&#123; name, enthusiasmLevel = 1 &#125;: Props) &#123;</span><br><span class="line">  if (enthusiasmLevel &lt;= 0) &#123;</span><br><span class="line">    throw new Error(&apos;You could be a little more enthusiastic. :D&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;hello&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;greeting&quot;&gt;</span><br><span class="line">        Hello &#123;name + getExclamationMarks(enthusiasmLevel)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种是通过无状态组件（stateless function component （SFC）））的形式引入，但是我们更常用的是通过类形式引入一个组件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component&lt;Props, object&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name, enthusiasmLevel = 1 &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    if (enthusiasmLevel &lt;= 0) &#123;</span><br><span class="line">      throw new Error(&apos;You could be a little more enthusiastic. :D&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;hello&quot;&gt;</span><br><span class="line">        &lt;div className=&quot;greeting&quot;&gt;</span><br><span class="line">          Hello &#123;name + getExclamationMarks(enthusiasmLevel)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">我们只需要考虑到props的类型，所以通过泛型接口的形式定义为React.Component&lt;Props, object&gt;,其中Props是我们类中的this.props,object是类中的this.state,此处我们只对props进行了校验。</span><br></pre></td></tr></table></figure></p>
<p>createStore<storestate>函数的泛型就收四个参数，按照教程提示就会报相应的错误，应该修正为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore&lt;StoreState, any, &#123;&#125;, &#123;&#125;&gt;(enthusiasm, &#123;</span><br><span class="line">  enthusiasmLevel: 1,</span><br><span class="line">  languageName: &apos;TypeScript&apos;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></storestate></p>
<ul>
<li>withRouter的作用  </li>
</ul>
<p>把不是通过路由切换过来的组件中，将react-router的history、location、match三个对象传入props对象上。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用方式</span><br><span class="line">***</span><br><span class="line">class Test extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(Test)</span><br></pre></td></tr></table></figure>
<p>问题： /Users/kirin/node_modules/@types/react/index.d.ts<br>(2312,14): Duplicate identifier ‘LibraryManagedAttributes’.</p>
<p>解决：<em>“skipLibCheck”</em>: true此方法不能从根本上解决问题。</p>
<p>问题：Parsing error: The keyword ‘import’ is reserved eslint<br>解决：项目根目录加入.eslintrc.json文件，并加入以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">    &quot;jsx&quot;: true,</span><br><span class="line">    &quot;modules&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">替换为</span><br><span class="line">&quot;parserOptions&quot;: &#123;</span><br><span class="line">    &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">        &quot;jsx&quot;: true,</span><br><span class="line">        &quot;modules&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者加入以下配置，并安装相关依赖</span><br><span class="line">&quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line"></span><br><span class="line">- npm install -g eslint@1.x.x babel-eslint@4.x.x</span><br><span class="line">- npm install -g eslint-plugin-react@3.x.x</span><br></pre></td></tr></table></figure></p>
<p>问题： The class method ‘render’ must be marked either ‘private’, ‘public’, or ‘protected’<br>解决： 此问题主要是由于tslint的规范，可以关闭此校验，通过在tslint.json中配置<code>member-access: false</code>,<a href="https://palantir.github.io/tslint/rules/member-access/" target="_blank" rel="noopener">详情可参考</a></p>
<p>问题： Class name must be in pascal case tslint<br>解决： 没找到合适的解决方案，最后只能取消eslint中extends中的配置，将tslint.json文件中<code>extends: []</code></p>
<p>问题： Module ‘“/Users/kirin/study/front/ts-study/node_modules/@types/react/index”‘ has no default export.<br>解决： 添加<code>&quot;allowSyntheticDefaultImports&quot;: true</code>配置到tsconfig.json,或者改成<code>import * as React from &#39;react&#39;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/react设计模式与最佳实践笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/react设计模式与最佳实践笔记/" itemprop="url">react设计模式与最佳实践笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T09:27:19+08:00">
                2019-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务端渲染的乐趣与益处"><a href="#服务端渲染的乐趣与益处" class="headerlink" title="服务端渲染的乐趣与益处"></a>服务端渲染的乐趣与益处</h2><ol>
<li>通用引用概念：这类应用往往通过服务端返回带有script标签的空html页面进行加载。加载完毕后，应用会操作浏览器中的DOM来显示UI，并与用户交互</li>
<li>react在服务端渲染相同组件的特性称为服务端渲染（SSR）</li>
<li>通用应用是指应用的代码可以同时用于服务端和客户端</li>
<li><p>使用服务端渲染的原因：</p>
<ul>
<li>SEO，如果为主流搜索引擎的爬虫提供空壳HTML，那么将无法从中解析出任何有意义的信息</li>
<li>通用代码库，方便交流</li>
<li>性能更强</li>
<li></li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/hexo+github搭建自己的个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/hexo+github搭建自己的个人博客/" itemprop="url">hexo+github搭建自己的个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:37+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><ul>
<li><p>安装node(mac为例)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">node -v (是否安装成功)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装git  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果上述步骤都没有问题，说明本地配置已经搞定，然后就可以在github上搭建项目了。</p>
<h2 id="github上创建并设置仓库"><a href="#github上创建并设置仓库" class="headerlink" title="github上创建并设置仓库"></a>github上创建并设置仓库</h2><p>新建仓库，在repository下填写你要创建的地址，这个地址就是你的域名，以我仓库为例，fkrin.github.io，<strong><em>一定要以xxx.github.io为结尾命名项目</em></strong>。创建完之后，点击setting设置仓库，找到Github Pages点击change theme选择主题并设置模版。</p>
<h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><ul>
<li>首先将项目clone下来<br><code>https://github.com/FKIRIN/fkirin.github.io.git</code></li>
<li>然后cd进入到项目根目录<br><code>cd fkirin.github.io</code></li>
<li><p>然后进行hexo初始化的相关命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s(启动项目，默认在4000端口)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在地址栏中输入localhost：4000可以看到这样的默认页面<img src="/images/2019-3/2019-03-19.jpg" alt="显示"></p>
</li>
<li><p>使用其他主题（以next为例）<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>然后配置_config.yml,将theme改为使用next，注意:有个空格<img src="/images/2019-3/2019-03-19-1.jpg" alt="显示">，<br>其他配置：  </p>
<ol>
<li>title: 网站标题</li>
<li>subtitle: 副标题</li>
<li>description: 个人签名</li>
<li>author: 姓名</li>
<li>language: zh-Hans<br>配置deploy的参数，参考上图。不能遗漏。</li>
</ol>
</li>
</ul>
<h2 id="提交项目部署"><a href="#提交项目部署" class="headerlink" title="提交项目部署"></a>提交项目部署</h2><ul>
<li>如果想要新增文章需要使用<br><code>hexo new &quot;名称&quot;</code>来新增md文件，否则无法识别。</li>
<li>安装部署工具<br><code>npm install hexo-deployer-git --save</code></li>
<li>移除子模块<br>因为next主题是其他仓库的内容，相当于本仓库的一个子模块，所以需要删除这个子模块将其当作此项目的一部分内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step1: </span><br><span class="line">$ git rm --cached themes/next</span><br><span class="line">rm &apos;themes/next&apos;</span><br><span class="line">step2: </span><br><span class="line">$ git add themes/next/</span><br><span class="line">注意： 这里next之后一定要加上/，表示将这个文件夹加入，而不是将这个文件夹当作一个子模块。</span><br><span class="line">step3: </span><br><span class="line">$ git commit -m &quot;提交信息&quot;</span><br><span class="line">$ git push origin master </span><br><span class="line">step4: </span><br><span class="line">$ hexo g （刷新）</span><br><span class="line">$ hexo d  （部署）</span><br><span class="line">（如果不执行这两个命令，网页上的内容不会更新)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考： <a href="https://upupming.site/2018/05/31/git-submodules/#%E4%BB%93%E5%BA%93%E5%86%85%E5%85%8B%E9%9A%86%E5%85%B6%E4%BB%96%E4%BB%93%E5%BA%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">仓库内克隆其他仓库遇到的问题</a><br>此处是直接以master分支开发的，具体可以新起一个dev分支，通过merge dev分支来更新master上的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/typescript学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/typescript学习笔记/" itemprop="url">typescript学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:37+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ul>
<li>布尔值 </li>
<li>数字（number） </li>
<li>字符串（string） </li>
</ul>
<ul>
<li><p>数组</p>
<ol>
<li>在元素类型后面接上[],表示由此元素组成一个数组<br><code>let list:number[] = [1, 2, 3];</code></li>
<li>使用数组泛型<br><code>let list:Array\&lt;number&gt; = [1, 2, 3]</code></li>
</ol>
</li>
<li><p>元组  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x: [string: number];</span><br><span class="line">x = [&apos;hello&apos;, 10];</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举<br><code>enmu Color { Red, Green, Blue}
let c: Color = Color.Green</code></p>
</li>
<li>Any 类型检查器不对这些值进行检查让他们直接通过编译器的检查<br><code>let notSure: any = 4;</code></li>
<li>void 表示没有任何类型，当一个函数没有返回值时。</li>
<li>Null和 Undefined</li>
<li><p>Never 类型表示的是那些永不存在的值的类型。例如never类型时那些总是会抛出异常或根本没有返回值的函数表达式或箭头函数表达式的返回值类型  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推断的返回值类型为never</span><br><span class="line">function fail() &#123;</span><br><span class="line">    return error(&quot;Something failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>object表示非原始类型，也就是除number，string， boolean， symbol， null或undefined之外的类型</p>
</li>
<li>类型断言(好比l类型转换，但是不进行特殊的数据检查h和解构)  </li>
</ul>
<ol>
<li>“尖括号语法”<br><code>let strLength: number = (\&lt;string\&gt;someValue).length</code>  </li>
<li>as语法<br><code>let strLength: number = (someValue as string).length;</code></li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>基本类型  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 可选属性  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">interface LabelledValue &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>只读属性  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let p1: Point = &#123; x: 10, y: 20&#125;;</span><br><span class="line">p1.x = 5 //error,一旦赋值就不可改变</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型<br>为了使用接口表示函数类型，我们给接口定义一个调用签名。只有参数列表和返回值类型的函数定义  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可索引的类型<br>可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span><br><span class="line"></span><br><span class="line">let myStr: string = myArray[0];</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口继承类<br>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。<strong>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：“Image”类型缺少“state”属性。</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>类的继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: number = 0) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 45) &#123;</span><br><span class="line">        console.log(&quot;Galloping...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用extends关键字创建了Animal的两个子类Horse和Snake，派生类包含类一个构造函数，必须调用super(),它会执行基类的构造函数。而且，<strong>在构造函数里访问this属性之前，我们一定要调用super()</strong></p>
<ul>
<li>公共，私有与受保护的修饰符</li>
</ul>
<ol>
<li>类默认伟为public，我们可以自由的访问程序里定义的成员。</li>
<li>private：不能在它的类的外部使用。</li>
<li>protected：protected成员在派生类中仍然可以访问。</li>
</ol>
<ul>
<li>private跟protected的区别</li>
</ul>
<ol>
<li>private： 私有的。在类中如果声明一个属性为私有，则表示这个属性仅仅属于这个类。仅仅能在这个类中进行这个属性的访问，在<strong>子类和类的实现</strong>的对象中都不能访问。在子类可以通过调用这个属性的方法来间接使用这个属性。</li>
<li>protected: 被保护的，针对对象。因为一个类可以化身为好多对象。对于这些对象共有的属性不应该让对象有访问和修改的权力。对于protected声明的属性可以在子类中访问它，<strong>不能在实现对象中访问</strong>。对于protected声明的构造方法，<strong>该类只能被继承不能被实现</strong></li>
</ol>
<ul>
<li>抽象类<br>抽象类作为其他派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&apos;roaming the earch...&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</strong> 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>书写完整函数类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number =</span><br><span class="line">    function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于返回值，在函数和返回值类型之前使用( =&gt; )符号，使之清晰明了。<strong>返回值类型是函数类型的必要部分，如果没有返回任何值，你也必须指定返回值类型为void而不能留空</strong></p>
<ul>
<li><p>可选参数和默认参数<br>可选参数通过在参数名旁使用？实现，<strong>可选参数必须跟在必须参数后面</strong></p>
</li>
<li><p>this和箭头函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    createCardPicker: function() &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line"></span><br><span class="line">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。解决方案是将return一个箭头函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/面试总结/" itemprop="url">面试总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:09+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>react将真实DOM抽象为虚拟DOM，然后通过新旧虚拟DOM这两个对象的差异(Diff算法)，最终将变化的部分重新渲染，提高效率。<br>虚拟dom算法：<br>1.用javascript对象表示DOM树的结构，然后用这个树构建一个真正的DOM树，插到文档中。<br>2.当状态变更的时候，重新构造一颗新的对象树，然后用对比新旧树，记录差异。<br>3.把记录的差异用到步骤1构建的真实DOM树，更新视图<br>一句话： 用js对象的形式来表示一颗真实的DOM树。</p>
<h3 id="react何时同步更新state"><a href="#react何时同步更新state" class="headerlink" title="react何时同步更新state"></a>react何时同步更新state</h3><ul>
<li>通过添加addEventLister来同步更新state</li>
<li><p>通过setTimeOut来同步更新state<br>原理： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。<br><a href="https://zhuanlan.zhihu.com/p/26069727" target="_blank" rel="noopener">react同步更新state</a></p>
<h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3></li>
</ul>
<ol>
<li>react hooks要解决的问题是状态共享，是继render-props和higher-order components之后的第三种状态共享方案，不会产生JSX嵌套地狱问题。状态共享可能描述的不是很恰当，状态逻辑复用，因为只共享数据处理逻辑，不会共享数据本身。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Toggle initial=&#123;false&#125;&gt;</span><br><span class="line">      &#123;(&#123; on, toggle &#125;) =&gt; (</span><br><span class="line">        &lt;Button type=&quot;primary&quot; onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt;</span><br><span class="line">        &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>react hooks解决的也是这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [open, setOpen] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setOpen(true)&#125;&gt;</span><br><span class="line">        Open Modal</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Modal</span><br><span class="line">        visible=&#123;open&#125;</span><br><span class="line">        onOk=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">        onCancel=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比,<br><strong><em>这个组件是没有状态的</em></strong>。</p>
<ol start="2">
<li>特性： </li>
</ol>
<ul>
<li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ul>
<ol start="3">
<li>hooks带来的约定<br>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。<br>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。<br>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。<br><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="noopener">参考</a></li>
</ol>
<h3 id="super作用："><a href="#super作用：" class="headerlink" title="super作用："></a>super作用：</h3><ol>
<li>初始化构造函数</li>
</ol>
<h3 id="keys作用："><a href="#keys作用：" class="headerlink" title="keys作用："></a>keys作用：</h3><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<h3 id="setState工作原理"><a href="#setState工作原理" class="headerlink" title="setState工作原理"></a>setState工作原理</h3><p>在代码中调用setState函数之后，react会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程，经过调和过程，react会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。react在得到元素树之后，react会自动计算出新的树与老树的节点差异，然后根据差异对界面进行局部更新重渲染。<br><a href="https://zhuanlan.zhihu.com/p/20328570?columnSlug=purerender" target="_blank" rel="noopener">详解</a></p>
<h3 id="Element与Component的区别"><a href="#Element与Component的区别" class="headerlink" title="Element与Component的区别"></a>Element与Component的区别</h3><p>Element是描述屏幕上所见内容的数据结构，是对于UI的对象表述。典型的React Element就是利用JSX构建的声明式代码片然后被转化为createElement的调用组合，而Component则是可以接收参数输入并且返回某个React Element的函数或者类。</p>
<h3 id="为什么需要使用React提供的Children-API而不是Javascript的map？"><a href="#为什么需要使用React提供的Children-API而不是Javascript的map？" class="headerlink" title="为什么需要使用React提供的Children API而不是Javascript的map？"></a>为什么需要使用React提供的Children API而不是Javascript的map？</h3><p>props.children获取到的内容可能是object也可能是array,React.Children.map已经将props.children不同类型的情况考虑在内了。</p>
<h3 id="setState函数的第二个参数的作用是什么？"><a href="#setState函数的第二个参数的作用是什么？" class="headerlink" title="setState函数的第二个参数的作用是什么？"></a>setState函数的第二个参数的作用是什么？</h3><p>该函数会在setState函数调用完成并且组件开始重新渲染的时候被调用，我们可以用该函数来监听渲染是否完成。</p>
<h3 id="react组件类型"><a href="#react组件类型" class="headerlink" title="react组件类型"></a>react组件类型</h3><ul>
<li><p>SFC(Stateless Functional Component)<br>React可以使用Function来创建Component，这类Component没有lifecycle，内部不维护state，只要传入的props有变化则进行重新渲染。</p>
</li>
<li><p>HOC(Higher-Order Components)<br>高阶组件就是一个方法，传入一个组件返回另一个组件。最常见的是react-redux里的connect方法，通过传入组件和map*ToProps方法，让组件和store连接。组件内部就可以直接通过props获得connect之后的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps,</span><br><span class="line">)(Component);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>高阶组件适合用来扩展功能，把这部分功能从业务组件中抽离出来，需要的套上，不需要的时候移除，对被包裹组件侵入性非常小</p>
<ul>
<li><p>Dynamic Component<br>在执行时才能确定具体的标签或者组件是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const &#123; tag: Tag, children &#125; = this.props;</span><br><span class="line">    return &lt;Tag&gt;&#123; children &#125;&lt;/Tag&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FaCC(Functions as Child Componets)<br>React children可以是Function类型，封装一个loading组件，会给children提供loading参数，业务组件贼根据loading判断需要render什么内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class LoadArea extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    loading: true,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    asyncFunc()</span><br><span class="line">        .then(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              loading: false,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">              loading: false,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;this.props.children(&#123;</span><br><span class="line">          ...this.props,</span><br><span class="line">          ...this.state,</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">render() &#123;</span><br><span class="line">    &lt;LoadingArea&gt;</span><br><span class="line">        (&#123; loading &#125;) =&gt; &#123;</span><br><span class="line">            loading</span><br><span class="line">                ? &lt;Wating /&gt;</span><br><span class="line">                : &lt;Main /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/LoadingArea&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Javascript概念"><a href="#Javascript概念" class="headerlink" title="Javascript概念"></a>Javascript概念</h2><h3 id="js微任务-宏任务"><a href="#js微任务-宏任务" class="headerlink" title="js微任务/宏任务"></a>js微任务/宏任务</h3><p>synchronous： 同步任务<br>asynchronous：异步任务<br>tast queue/callback queue： 任务队列<br>execution context stack： 执行栈<br>heap： 堆<br>stack： 栈<br>macro-task： 宏任务<br>micro-task： 微任务  </p>
<ol>
<li>js是单线程，将任务分为同步任务和异步任务。一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，结果不过是在执行栈中再添加一个执行环境，这个过程可以是无限进行下去的，除非发生了栈溢出。  </li>
<li>同步和异步任务分别进入不同的执行场所，同步的进入主线程，异步的进入event table并注册函数。当指定的事情完成时，event table会将这个函数移入event queue。主线程内的任务执行完毕为空，会去event queue读取对应的函数，进入主线程执行。上述过程不断重复，也就是常说的Event Loop（事件循环）</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() =&gt; &#123;</span><br><span class="line">        console.log(&apos;发送成功!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一段简易的ajax请求代码，ajax进入event table，注册回调函数success。执行console.log（’代码执行结束’）。ajax事件完成，回调函数success进入event queue。主线程从event queue读取回调函数success并执行。</p>
<ol start="4">
<li>微任务、宏任务<br>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于它们的执行顺序，event loop的走向和取值。<br>js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后在执行微任务，将微任务放入event queue。当你往外拿的时候先从微任务手里拿回调函数，然后再从宏任务的queue上拿宏任务的回调函数。<br>宏任务一般： 包括整体代码script, setTimeout, setInterval, setImmediate.<br>微任务： 原生Promise（有些实现的promise 将then方法放到了宏任务中）、process.nextTick、MutaionObserver、Object.observer(已废弃)  </li>
</ol>
<p>参考： <a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">微任务/宏任务详解</a></p>
<h3 id="DOMContentLoaded-Load事件"><a href="#DOMContentLoaded-Load事件" class="headerlink" title="DOMContentLoaded/Load事件"></a>DOMContentLoaded/Load事件</h3><p>结合DOM文档加载的加载步骤，DOMContentLoaded事件/Load事件，触发时机如下：  </p>
<ol>
<li>解析HTMl结构</li>
<li>加载外部脚本和样式文件。</li>
<li>解析并执行脚本代码。 // 部分脚本会阻塞页面的加载</li>
<li>DOM树构建完成。 // DOMContentLoaded事件</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。 // load事件</li>
</ol>
<h3 id="js数组方法"><a href="#js数组方法" class="headerlink" title="js数组方法"></a>js数组方法</h3><ul>
<li>slice方法返回从该为参数指定位置开始到当前数组末尾的所有项。如果两个参数，该方法返回起始位置和结束位置之间的项但不包括结束位置的项。<strong><em>该方法不会影响愿数组</em></strong></li>
<li><p>splice最强大的数组方法：</p>
<ol>
<li>可以删除任意数量的项，只需指定 2 个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项</li>
<li>插入:可以向指定位置插入任意数量的项，只需提供 3 个参数:起始位置、0(要删除的项数) 和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如， splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li><p>替换:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。</p>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)</p>
</li>
</ol>
</li>
<li>every和some  <ol>
<li>对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true   </li>
<li>对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
</ol>
</li>
<li>reduce 遍历数组中的所有项并返回一个最终值。方法接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</li>
</ul>
<h3 id="proto和prototype的区别和关系"><a href="#proto和prototype的区别和关系" class="headerlink" title="proto和prototype的区别和关系"></a><em>proto</em>和prototype的区别和关系</h3><p>首先贴上关键图片: <img src="/images/2019-3/2019-03-20.jpg" alt="原型图">  </p>
<ol>
<li>方法（Function）是对象，方法的原型（Function.prototype）是对象。因此就具有对象共有的特点，即：对象具有属性<em>proto</em>可称为隐式原型，一个对象的隐式原型指向<strong>构造该对象的构造函数的原型</strong>，这就保证了实例能够访问在构造函数原型中定义的属性和方法。</li>
<li>方法（Function）是个特殊的对象，除了具有<em>proto</em>属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象有属性constructor,这个属性包含了一个指针，指回原构造函数。  </li>
</ol>
<p>总结： </p>
<ol>
<li>对象具有属性<em>proto</em>，<strong>指向该对象的构造函数的原型对象</strong>，Object.prototype的<em>proto</em>属性指向null。</li>
<li>方法除了有属性<em>proto</em>，还有属性prototype,prototype指向该方法的原型对象。<h4 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以new运算符调用构造函数的时候，函数内部实际上发生以下变化：</p>
<ol>
<li>创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到this引用的对象中</li>
<li>新创建的对象由this所引用，并且最后隐式的返回this</li>
</ol>
<p><a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener">详解原型链</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>计数排序的思想  </p>
<ol>
<li>首先会对每个输入进行频率统计，得到元素的频率表；</li>
<li>然后将频率表转换为该元素的开始索引；</li>
<li>根据各个元素的开始索引，将相同元素分类到临时数组中。</li>
<li>最后将临时数组中的元素写回到原数组中。</li>
</ol>
</li>
<li><p>桶排序的思想  </p>
<ol>
<li>根据输入建立适当个数的桶，每个桶可以存放某个范围内的元素；</li>
<li>将落在特定范围内的所有元素放入对应的桶中；</li>
<li>对每个非空的桶中元素进行排序，可以选择通用的排序方法，比如插入、快排</li>
<li>按照划分的范围顺序，将桶中的元素依次取出。排序完成。</li>
</ol>
</li>
<li><p>基数排序<br>基数排序按照从右往左的顺序，依次将每一位都当作一次关键字，然后按照关键字对数组排序，每一轮排序都基于上轮排序后的结果。最后一轮，最左边那位也作为关键字并排序，整个数组就达到有序状态。</p>
<p><a href="https://www.cnblogs.com/sun-haiyu/p/7859252.html" target="_blank" rel="noopener">参考</a></p>
</li>
</ul>
<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><ul>
<li><p>防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">      // 1、获取这个按钮，并绑定事件</span><br><span class="line">      var myDebounce = document.getElementById(&quot;debounce&quot;);</span><br><span class="line">      myDebounce.addEventListener(&quot;click&quot;, debounce(sayDebounce));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、防抖功能函数，接受传参</span><br><span class="line">    function debounce(fn) &#123;</span><br><span class="line">      // 4、创建一个标记用来存放定时器的返回值</span><br><span class="line">      let timeout = null;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        // 5、每次当用户点击/输入的时候，把前一个定时器清除</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 6、然后创建一个新的 setTimeout，</span><br><span class="line">        // 这样就能保证点击按钮后的 interval 间隔内</span><br><span class="line">        // 如果用户还点击了的话，就不会执行 fn 函数</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">          fn.call(this, arguments);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、需要进行防抖的事件处理</span><br><span class="line">    function sayDebounce() &#123;</span><br><span class="line">      // ... 有些需要防抖的工作，在这里执行</span><br><span class="line">      console.log(&quot;防抖成功！&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节流: 指定时间间隔内只会执行一次任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">      // 1、获取按钮，绑定点击事件</span><br><span class="line">      var myThrottle = document.getElementById(&quot;throttle&quot;);</span><br><span class="line">      myThrottle.addEventListener(&quot;click&quot;, throttle(sayThrottle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、节流函数体</span><br><span class="line">    function throttle(fn) &#123;</span><br><span class="line">      // 4、通过闭包保存一个标记</span><br><span class="line">      let canRun = true;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数</span><br><span class="line">        if(!canRun) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 6、将 canRun 设置为 false，防止执行之前再被执行</span><br><span class="line">        canRun = false;</span><br><span class="line">        // 7、定时器</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">          fn.call(this, arguments);</span><br><span class="line">          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span><br><span class="line">          canRun = true;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、需要节流的事件</span><br><span class="line">    function sayThrottle() &#123;</span><br><span class="line">      console.log(&quot;节流成功！&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="重绘与回流（重排"><a href="#重绘与回流（重排" class="headerlink" title="重绘与回流（重排"></a>重绘与回流（重排</h3><ul>
<li><p>重绘（repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，由于只需要UI层面的重新像素绘制，因此损耗较少。常见的重绘操作有：  </p>
<ol>
<li>改变元素颜色</li>
<li>改变元素背景色</li>
<li>more。。。</li>
</ol>
</li>
<li><p>回流（reflow): 又叫重排。当元素的尺寸、结构或者触发某些属性时，浏览器会重新刷新页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此时较重的操作。常见的回流操作有：</p>
<ol>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸/位置/内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类</li>
<li>more。。。</li>
</ol>
</li>
</ul>
<p><strong>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高</strong><br>为什么需要节流？ 因为有些事情会造成浏览器的回流，而回流会使浏览器的开销增大，所以通过节流来防止增大浏览器开销的事情。<br>如何避免大量使用重绘与回流呢？</p>
<ol>
<li>避免频繁操作样式，可汇总后统一一次修改</li>
<li>尽量使用class进行样式修改，而不是直接操作样式</li>
<li>减少DOM的操作，可使用字符串一次性插入</li>
</ol>
<h3 id="js冻结对象"><a href="#js冻结对象" class="headerlink" title="js冻结对象"></a>js冻结对象</h3><ol>
<li>Object.freeze() 冻结一个对象：<ul>
<li>不能向这个对象添加新属性  </li>
<li>不能修改其已有属性的值  </li>
<li>不能删除已有属性  </li>
<li>不能修改该对象已有属性的可枚举性、可配置性、可写性</li>
</ul>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p>arguments.callee是为了实现函数更松散的耦合，最简单的实例，函数的递归调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if (num &lt;=1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的属性length和prototype，length属性表示函数希望接收的命名参数的个数。</p>
</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>charAt 返回字符串的位置</li>
<li>charCodeAt 返回字符串的字符编码</li>
<li>concat 用于字符串的拼接</li>
<li>slice，substr，sbustring用来获取字符串，不会修改原有字符串返回新的字符串</li>
<li>trim方法用来去除字符串的空格，返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变</li>
<li>localeCompare 比较两个字符串，返回 -1， 0，1。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;yellow&quot;; alert(stringValue.localeCompare(&quot;brick&quot;)); //1 alert(stringValue.localeCompare(&quot;yellow&quot;)); //0 alert(stringValue.localeCompare(&quot;zoo&quot;)); //-1</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li><p>object.defineProperty这个方法 接收三个参数:属性所在的对象、属性的名字和一个描述符对象（必须设置configurable、enumerable、writable 和 value其中的一个值或多个值）。</p>
</li>
<li><p>hasOwnProperty()方法可以检测一个属性是存在于实例中</p>
</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>为实现多参函数提供了一个递归降解的实现思路—把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol>
<li>可以读取函数内部的变量。</li>
<li>让这些变量的值始终保持在内存中。<br>弊端： 占用内存，慎用。</li>
</ol>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Cat() &#123;</span><br><span class="line">  say() &#123;</span><br><span class="line">    console.log(&quot;meow ~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat() &#123;</span><br><span class="line">  Object.defineProperty(Cat.proptotype, &quot;say&quot;, &#123;</span><br><span class="line">    value: function() &#123; console.log(&quot;meow ~&quot;) &#125;,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">function readonly(target, name, desciptor) &#123;</span><br><span class="line">  desciptor.writable = false;</span><br><span class="line">  return descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  say() &#123;</span><br><span class="line">    console.log(&quot;meow `&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看出作用于类的属性的时候的装饰器函数接收的参数就是上述ES6中的类定义属性时候使用Object.defineProperty时接收的参数是一样的。</p>
<p><strong><em>本质上也就是说装饰器在作用于类的属性的时候，实际上是通过Object.defineProperty</em></strong><br>装饰一个类：<br>装饰一个类的时候本身本质上是一个函数，没有descriptor，target是这个函数本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function isAnimal(target) &#123;</span><br><span class="line">    target.isAnimal = true;</span><br><span class="line">  	return target;</span><br><span class="line">&#125;</span><br><span class="line">@isAnimal</span><br><span class="line">class Cat &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">console.log(Cat.isAnimal);</span><br></pre></td></tr></table></figure></p>
<p>也就是说，上面的@isAnimal其实就是做了下面这件事：<br><code>Cat = isAnimal(function Cat() { ... });</code> </p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>操作节点： </p>
<ol>
<li>appendChild: 向childNodes列表的末尾添加一个节点</li>
<li>insertBefore: 这个方法要接收两个参数，要插入的节点和作为参照的节点，吐过参照节点是null，则insertBefore与appendChild执行相同的操作</li>
<li>replaceChild: 方法接收的两个参数是要插入的节点和要替换的节点</li>
<li>removeChild: 接受一个参数即要移除的节点</li>
<li>cloneNode: 创建这个节点完全相同的副本，该方法接受一个boolean值参数，表示是否执行深复制，true执行深复制，也就是复制节点及其整个子节点树。</li>
</ol>
<p>查找元素: </p>
<ol>
<li>getElementById</li>
<li>getElementsByTagName: 接受元素的标签名，返回的包含0或者多个元素的NodeList。</li>
<li>getElementsByName: 这个方法返回带有给定name特性的所有元素</li>
<li>querySelector: 接受一个css选择符，返回与该模式匹配的第一个元素,没有返回null。</li>
<li>querySelectorAll: 接受一个css选择符，返回Nodelist的实例。</li>
<li>matchesSelector: 接受一个选择符，如果调用元素与该元素匹配返回true否则false</li>
<li>getElementsByClassName: 接受一个包含一个或多个类名的字符串，返回带有指定类的所有元素的NodeList</li>
<li>DOMTokenList: 为所有元素添加classList属性，这个classList属性是新集合DOMTokenList的实例。含有4个属性，add——将给定的字符串添加到列表中，如果已经存在则不添加;contains——表示列表中是否存在给定的值，如果存在则返回true,否则返回false;remove——从列表中删除给定的字符串;toggle——如果列表中已经存在给定的值，删除它，如果没有给定的值，添加它。</li>
</ol>
<p>创建元素</p>
<ol>
<li>document.createElement: 接受一个参数即要创建元素的标签名</li>
<li>document.createTextNode: 创建新文本节点，接受一个参数插入节点中的文本。</li>
<li>documentFragment.createDocumentFragment: DocumentFragment在文档中没有对应的标记，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。虽然不能把文档片段直接添加到文档中，但是可以将它作为“仓库”来使用，即在里面保存将来可能会添加到文档中的节点。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">    var ul = document.getElementById(&quot;myList&quot;);</span><br><span class="line">    var li = null;</span><br><span class="line">    for (var i=0; i &lt; 3; i++)&#123;</span><br><span class="line">        li = document.createElement(&quot;li&quot;);</span><br><span class="line">        li.appendChild(document.createTextNode(&quot;Item &quot; + (i+1)));</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line">    // 一次性放入也有利于提升性能</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>焦点管理<br>document.activeElement属性始终引用DOM中当前获得来焦点的元素，元素获得焦点的方式有页面加载、用户输入和在代码中调用focus()方法，document.hasFocus勇于确定文档是否获得了焦点。</p>
</li>
<li><p>scrollIntoView<br>document.forms[0].scrollIntoView通过浏览器窗口或某个容器元素，调用就可以出现在视口中。</p>
</li>
<li><p>事件处理程序<br>DOM2级事件，addEventListener和removeEventListener接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。布尔值参数为true表示在捕获阶段调用事件处理程序；如果是false表示在冒泡阶段调用事件处理程序。<br>移除的事件处理函数必须与传入的addEventListener相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">    btn.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">        alert(this.id);</span><br><span class="line">    &#125;, false);</span><br><span class="line">//这里省略了其他代码</span><br><span class="line">btn.removeEventListener(&quot;click&quot;, function()&#123; //没有用! </span><br><span class="line">  alert(this.id);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">    var handler = function()&#123;</span><br><span class="line">        alert(this.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    btn.addEventListener(&quot;click&quot;, handler, false);</span><br><span class="line">//这里省略了其他代码</span><br><span class="line">btn.removeEventListener(&quot;click&quot;, handler, false); //有效!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>图像ping 使用<code>&lt;img&gt;</code>标签。动态创建图像经常用于图像Ping，图像ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过 图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时 候接收到的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.onload = img.onerror = function()&#123;</span><br><span class="line">    alert(&quot;Done!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = &quot;http://www.example.com/test?name=Nicholas&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSONP<br>JSONP是JSON with padding的简写。JSONP由两部分组成：回调函数和数据。<code>callback({ &quot;name&quot;: &quot;Nicholas&quot; })</code>,回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的JSON数据，如：<code>http://freegeoip.net/json/?callback=handleResponse</code>.JSONP是通过动态script元素来使用的，使用时可以为src属性指定一个跨域URL。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">alert(&quot;You’re at IP address &quot; + response.ip + &quot;, which is in &quot; +</span><br><span class="line">          response.city + &quot;, &quot; + response.region_name);</span><br><span class="line">&#125;</span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;; document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>JSONP的不足，从其他域中加载代码执行，安全性；确定JSONP请求是否失败并不容易，新增了一个onerror事件处理程序。</p>
<h3 id="javascript高级技巧"><a href="#javascript高级技巧" class="headerlink" title="javascript高级技巧"></a>javascript高级技巧</h3><ul>
<li>高级函数  </li>
</ul>
<ol>
<li>安全的类型检测，javascript内置的类型检测机制并非完全可靠，比如typeof经常会导致检测数据类型时得到不靠谱的结果。解决问题的办法时统一的，通过调用Object原声的toString方法，返回[Object NativeConstructorName]格式的字符串。每个类在内部都有一个[[class]]属性。比如<code>Object.prototype.toString.call(value) // &quot;[object Array]&quot;</code>,由于原生数组的构造函数与全局作用域无关，因此使用toString方法就能保证返回统一的值。</li>
<li>作用域安全的构造函数<br>构造函数时通过new操作符调用的函数，当使用new调用时，构造函数内部的用到的this对象会指向新创建的对象实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">alert(window.name);</span><br><span class="line">alert(window.age);</span><br><span class="line">alert(window.job);</span><br><span class="line">//&quot;Nicholas&quot;</span><br><span class="line">//29</span><br><span class="line">//&quot;Software Engineer&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当没有使用new操作符来调用构造函数时，由于this对象是在运行时绑定的，所以直接调用Person(),this会映射到全局对象window上，所以这里对属性的偶然覆盖会导致页面上出现错误，解决方法就是创建一个作用域安全的构造函数，通过确认this对象是正确类型的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">        if (this instanceof Person)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.job = job;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Person(name, age, job);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>惰性载入函数<br>因为浏览器的差异，多数JavaScript代码包含了大量if语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function createXHR()&#123;</span><br><span class="line">        if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;</span><br><span class="line">            if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">                var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                                &quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">i,len;</span><br><span class="line">                for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         new ActiveXObject(versions[i]);</span><br><span class="line">                         arguments.callee.activeXString = versions[i];</span><br><span class="line">                          break;</span><br><span class="line">                     &#125; catch (ex)&#123;</span><br><span class="line">//跳过 &#125;</span><br><span class="line">            return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>惰性载入表示函数执行的分之仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调 用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任 何对原函数的调用都不用再经过执行的分支了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function createXHR()&#123;</span><br><span class="line">        if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">            createXHR = function()&#123;</span><br><span class="line">              return new XMLHttpRequest();</span><br><span class="line">&#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;</span><br><span class="line">    createXHR = function()&#123;</span><br><span class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">   i, len;</span><br><span class="line">&quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">                    for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                          new ActiveXObject(versions[i]);</span><br><span class="line">                          arguments.callee.activeXString = versions[i];</span><br><span class="line">                             break;</span><br><span class="line">                        &#125; catch (ex)&#123;</span><br><span class="line">//skip &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">                return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">            &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">            createXHR = function()&#123;</span><br><span class="line">                throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    return createXHR();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种实现惰性载入的方式在声明函数时就指定适当的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var createXHR = (function()&#123;</span><br><span class="line"> if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">return function()&#123;</span><br><span class="line"> &#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                            &quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">            i, len;</span><br><span class="line">        for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                new ActiveXObject(versions[i]);</span><br><span class="line">                arguments.callee.activeXString = versions[i];</span><br><span class="line">                break;</span><br><span class="line">&#125; catch (ex)&#123;</span><br><span class="line">//skip &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; &#125;)();</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>函数绑定<br>函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">        message: &quot;Event handled&quot;,</span><br><span class="line">        handleClick: function(event)&#123;</span><br><span class="line">            alert(this.message);</span><br><span class="line">&#125; &#125;;</span><br><span class="line">    var btn = document.getElementById(&quot;my-btn&quot;);</span><br><span class="line">    EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick);</span><br><span class="line"></span><br><span class="line">当按下按钮调用该函数，显示的时undefined，问题在与没有保存handler.handleClick的执行环境，this对象指向了DOM按钮而非handler。解决方案是通过内部使用闭包直接调用handler.handleClick。  </span><br><span class="line">EventUtil.addHandler(btn, &quot;click&quot;, function(event&#123;</span><br><span class="line">        handler.handleClick(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所以出现了bind函数，接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function bind(fn, context)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">          return fn.apply(context, arguments); </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var handler = &#123;</span><br><span class="line">  message: &quot;Event handled&quot;,</span><br><span class="line">  handleClick: function (event) &#123;</span><br><span class="line">    alert(this.message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var btn = document.getElementById(&quot;my-btn&quot;);</span><br><span class="line">EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler));</span><br></pre></td></tr></table></figure></p>
<p>ES5定义了原生的bind方法，上述案例可以这样使用。<code>EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler));</code></p>
<ol start="5">
<li>函数柯里化<br>用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定时一致的：使用一个闭包返回一个函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn)&#123;</span><br><span class="line">       var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">       return function()&#123;</span><br><span class="line">           var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">           var finalArgs = args.concat(innerArgs);</span><br><span class="line">           return fn.apply(null, finalArgs);</span><br><span class="line">   &#125;; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>防篡改对象</li>
</ul>
<ol>
<li><p>不可扩展对象:<br>Object.preventExtensions()方法不能给对象添加属性和方法。虽然不能给对象添加新成员，但已有的成员丝毫不受影响，你仍然可以修改和删除已有的成员，还可以确定对象是否可以扩展。</p>
</li>
<li><p>密封的对象：<br>Object.seal().密封对象不可扩展，而且已有成员的[[Configurable]]特性被设置为false，意味着不能删除属性和方法，属性值是可以修改的。</p>
</li>
<li><p>冻结的对象：<br>Object.freeze()。冻结的对象既不可扩展又是密封的而且对象数据属性的writable特性会被设置为false。</p>
</li>
</ol>
<h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>web worker最重要的是它执行的javascript代码完全在另一个作用域，在web worker中，同样又一个全局对象和其他对象以及方法。web worker中的代码不能访问dom，也无法通过任何方式影响页面的外观。<br>web worker中的全局对象是worker对象本身，在这个特殊的全局作用域中，this和self引用的都是worker对象。为便于处理数据，web worker本身也是一个最小化的运行环境。</p>
<ol>
<li>使用worker。<br><code>var worker = new Worker(&#39;stufftodo.js&#39;)</code>,然后浏览器会下载stufftodo.js,通过postMessage()方法传递消息。worker通过message和error事件与页面通信，terminate()方法可以停止worker工作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// worker内部代码</span><br><span class="line">self.onmessage = function(event)&#123;</span><br><span class="line">    var data = event.data;</span><br><span class="line">//别忘了，默认的 sort()方法只比较字符串 </span><br><span class="line">data.sort(function(a, b)&#123;</span><br><span class="line">       return a – b;</span><br><span class="line">    &#125;);</span><br><span class="line">    self.postMessage(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 页面中</span><br><span class="line">var data = [23,4,7,9,2,14,6,651,87,41,7798,24],</span><br><span class="line">    worker = new Worker(&quot;WebWorkerExample01.js&quot;);</span><br><span class="line">worker.onmessage = function(event)&#123;</span><br><span class="line">    var data = event.data;</span><br><span class="line">  //对排序后的数组进行操作 </span><br><span class="line">&#125;;</span><br><span class="line">//将数组发送给 worker 排序 </span><br><span class="line">worker.postMessage(data);</span><br></pre></td></tr></table></figure>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>通过优化从而提高页面的加载速度：</p>
<ul>
<li>HTML优化</li>
</ul>
<ol>
<li>避免html中书写CSS代码，因此这样难以维护。</li>
<li>使用Viewport加速页面的渲染。</li>
<li>使用语义化标签，减少CSS代码，增加可读性和SEO。</li>
<li>减少标签的使用，DOM解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。</li>
<li>减少src、href等值为空，因为即使为空浏览器还是会发起HTTP请求</li>
<li>减少DNS查询的次数</li>
</ol>
<ul>
<li>CSS优化</li>
</ul>
<ol>
<li>优化选择器路径： 使用.c {}而不是.a.b.c {}。</li>
<li>选择器合并： 共同的属性内容提取出来，压缩空间和资源开销。</li>
<li>精确样式：使用padding-left:10px而不是padding: 0 0 0 10px。</li>
<li>雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。</li>
<li>减少通配符： .a.b * {}这样的选择器，根据从右到左的解析顺序会优先遍历整个DOM，性能大大损耗。</li>
<li>少用float： float在渲染时计算量比较大，可以使用flex布局。</li>
<li>为0值去单位： 增加兼容性</li>
<li>压缩文件大小，减少资源下载负担。</li>
</ol>
<ul>
<li>Javascript优化</li>
</ul>
<ol>
<li>将script标签放在body之后，避免js的执行卡住DOM的渲染，最大程度保证页面尽快的展示出来。</li>
<li>合并js代码：提取公共方法，进行封装或者面向对象设计</li>
<li>CSS能做的事情，尽量不用JS来做，毕竟js的解析执行比较粗暴，而CSS效率更高。</li>
<li>尽可能逐条操作DOM，并预定好CSS样式，从而减少reflow或者repaint的次数。</li>
<li>尽可能少地创建DOM，而是在HTML和CSS中使用display:none来隐藏，按需显示。</li>
<li>压缩文件大小，减少资源下载负担。</li>
</ol>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h3><ol>
<li>推荐用for in来遍历对象，for of来遍历数组</li>
<li>for in循环出的是key， for of循环出的是value</li>
<li>for of 不能循环普通的对象，需要通过和object.keys搭配使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var student=&#123;</span><br><span class="line">    name:&apos;wujunchuan&apos;,</span><br><span class="line">    age:22,</span><br><span class="line">    locate:&#123;</span><br><span class="line">    country:&apos;china&apos;,</span><br><span class="line">    city:&apos;xiamen&apos;,</span><br><span class="line">    school:&apos;XMUT&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var key of Object.keys(student))&#123;</span><br><span class="line">    //使用Object.keys()方法获取对象key的数组</span><br><span class="line">    console.log(key+&quot;: &quot;+student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ol>
<li>TCP(Transmission Control Protocol)是面向连接的协议，也就是说，在收发数据前必须和对方建立可靠的连接。一个TCP连接需经过3次对话，断开需要经过4次</li>
<li>UDP是一个非连接的协议，传输数据之前源端和终端不需建立连接。当他想传送数据时就简单地去抓取来自应用程序的数据，并尽可能地扔到网络上。（常用ping命令检测主机到主机之间是否可通信，就是udp的实例<br>区别：</li>
</ol>
<ul>
<li>基于连接于无连接；</li>
<li>对系统资源的要求（TCP较多，UDP较少）</li>
<li>UDP程序结构较简单</li>
<li>流模式与数据报模式</li>
<li>TCP保证数据正确性，UDP可能丢包</li>
<li>TCP保证数据顺序，UDP不保证</li>
</ul>
<h3 id="TCP协议如何提高传输效率"><a href="#TCP协议如何提高传输效率" class="headerlink" title="TCP协议如何提高传输效率"></a>TCP协议如何提高传输效率</h3><ul>
<li>滑动窗口</li>
<li>快重传</li>
<li>延迟应答</li>
<li>捎带应答</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>1** 信息，服务器接收到请求，需要请求者继续执行操作。  <ol>
<li>101切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议。</li>
</ol>
</li>
<li>2** 成功，操作被成功接收并处理</li>
<li>3** 重定向，需要进一步的操作以完成请求<ol>
<li>304未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。</li>
</ol>
</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生了错误。</li>
</ul>
<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><ul>
<li><p>W3C  </p>
<ol>
<li>参数的数据类型，GET只接受ASCII字符，而POST没有限制，允许二进制</li>
<li>GET在浏览器回退/刷新时是无害的，而POST会再次提交请求</li>
<li>GET请求只能进行url编码（application/x-www-form-urlencoded）,而POST支持多种编码方式（application/x-www-form-urlencoded或multipart/form-data），可以为二进制使用多重编码。</li>
<li>POST比GET更安全，因为GET参数直接暴露在URL上，POST参数在HTTP消息主体中，而且不会保存在浏览器历史或web服务器日志中。</li>
<li>对参数数据长度的限制，GET方法URL的长度是受限制的，最大是2048个字符，POST参数数据是没有限制的。</li>
<li>GET请求会被浏览器主动缓存，POST不会，除非手动设置。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会保留。</li>
<li>GET请求可被收藏为书签，POST不能。</li>
</ol>
</li>
<li><p>WSC</p>
<ol>
<li>GET和POST本质上都是TCP链接，给GET加上request body，给POST加上url参数，技术上是可行的。但是由于HTTP的规定和浏览器/服务器的限制，导致在应用过程中体现出一些不同。</li>
<li>GET会产生一个TCP数据包，POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ol>
</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC（Block formating context）直译为”块级格式化上下文”。它是一个独立的渲染区域，它规定了北部的block-level-box如何布局，并且与这个区域外部毫不相干。<br>形成条件： </p>
<ul>
<li>浮动元素， float除none以外的值</li>
<li>定位元素，position（absolute， fixed）</li>
<li>display为以为其中之一的值，inline-block，table-cell，table-caption</li>
<li>overflow除了visible以外的值（hidden，scroll，auto）  </li>
</ul>
<p>BFC的特性：</p>
<ul>
<li>内部的BOX会在垂直方向上一个接一个的位置</li>
<li>垂直方向上的距离由margin决定</li>
<li>bfc的区域不会于float的元素区域重叠</li>
<li>计算bfc的高度时，浮动元素也参与计算</li>
<li>bfc就是页面上的一个独立容器，容器里面的自元素不会影响外面元素</li>
</ul>
<h3 id="position-sticky（兼容性比较低）"><a href="#position-sticky（兼容性比较低）" class="headerlink" title="position: sticky（兼容性比较低）"></a>position: sticky（兼容性比较低）</h3><p>粘性定位，是position：relative和postion： fixed的结合体。<br>生效规则：</p>
<ul>
<li>top, right, bottom, left四个阙值其中之一。</li>
<li>设定为position：sticky元素的任意父节点的overflow属性必须是visible，否则position不会生效。  </li>
</ul>
<p><a href="http://www.cnblogs.com/coco1s/p/6402723.html" target="_blank" rel="noopener">参考1</a><br><a href="https://segmentfault.com/a/1190000006740129" target="_blank" rel="noopener">参考2</a></p>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><ol>
<li><p>content-box默认值，标准盒子模型。width与height只包括内容的宽和高，不包括边框，内边距，外边距。尺寸计算公式： width = 内容的宽度，height = 内容的高度。宽度和高度都不包含内容的边框（border）和内边距（padding）</p>
</li>
<li><p>border-box width和height属性包括内容，内边距和边框，但不包括外边距。这里的纬度计算公式为： width = border + padding + 内容的width， height = border + padding + 内容的height。</p>
</li>
</ol>
<h3 id="css全局污染的解决方案"><a href="#css全局污染的解决方案" class="headerlink" title="css全局污染的解决方案"></a>css全局污染的解决方案</h3><p>我们经常通过class或者id选择器来修改html的样式，并且允许在一个css文件中存在两个class名字一样的样式，但是当多人合作开发一个页面时，难免出现类名重复导致样式互相影响的问题。</p>
<ol>
<li>scoped属性： html5带来了很多强势的功能，其中scoped属性可以让我们更好的控制样式，让其变成局部的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.class &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">不过存在兼容性问题，在chrome下时无效的，只有在firefox下才有效。</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">2. css in js ： 类似于react中的jsx一样的一个语法糖，你可以命名一个对象变量，然后利用react的style，传对应的style对象进去。</span><br></pre></td></tr></table></figure>
<p>const styles = {<br>  bar: {<br>    backgroundColor: ‘red’;<br>  }<br>}<br>const example = (props) =&gt; (<br>  <div style="{styles.bar}"></div><br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. CSS Modules： 现在的网页开发都是通过组件，模块化开发。css modules就是将css模块化的技术。可参考[阮老师的教程](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)。</span><br><span class="line">大致如此： </span><br><span class="line">- 将class编译成哈希字符串</span><br></pre></td></tr></table></figure></p>
<p></p><h1 class="_3zyde4l1yATCOkgn-DBWEL"><br>  Hello World<br></h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用webpack的css-loader插件，它对css modules的支持最好。</span><br></pre></td></tr></table></figure><p></p>
<p>module.exports = {<br>  entry: __dirname + ‘/index.js’,<br>  output: {<br>    publicPath: ‘/‘,<br>    filename: ‘./bundle.js’<br>  },<br>  module: {<br>    loaders: [<br>      {<br>        test: /.jsx?$/,<br>        exclude: /node_modules/,<br>        loader: ‘babel’,<br>        query: {<br>          presets: [‘es2015’, ‘stage-0’, ‘react’]<br>        }<br>      },<br>      {<br>        test: /.css$/,<br>        loader: “style-loader!css-loader?modules”<br>      },<br>    ]<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`style-loader!css-loader?modules`最为关键，css-loader后加入查询参数modules表示打开CSS Modules功能。</span><br><span class="line">- 全局作用域  </span><br><span class="line">:global(.className)的语法，表示声明一个全局规则，凡是这样生命的都不会编译成哈希字符串。</span><br><span class="line">- 定制哈希类名  </span><br><span class="line">css-loader默认的哈希算法是[hash:base64]，会将.title编译成._3zyde4l1yATCOkgn-DBWEL这样的字符串。webpack可以定制哈希字符串的格式。</span><br></pre></td></tr></table></figure></p>
<p>module: {<br>  loaders: [<br>    // …<br>    {<br>      test: /.css$/,<br>      loader: “style-loader!css-loader?modules&amp;localIdentName=[path][name]—[local]—[hash:base64:5]”<br>    },<br>  ]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- class的组合</span><br><span class="line"></span><br><span class="line">  在同一个css中</span><br></pre></td></tr></table></figure></p>
<p>.className {<br>  background-color: blue;<br>}</p>
<p>.title {<br>  composes: className;<br>  color: red;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-  其他模块  </span><br><span class="line">antoher.css</span><br></pre></td></tr></table></figure></p>
<p>.className {<br>  background-color: blue;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App.css 可以继承another.css里面的规则</span><br></pre></td></tr></table></figure></p>
<p>.title {<br>  composes: className from ‘./another.css’;<br>  color: red;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 输入变量  </span><br><span class="line">css modules支持使用变量，不过需要安装PostCSS和postcss-modules-values</span><br><span class="line">`npm install --save postcss-loader postcss-modules-values`</span><br><span class="line">把postcss-loader加入webpack.config.js</span><br></pre></td></tr></table></figure></p>
<p>var values = require(‘postcss-modules-values’);</p>
<p>module.exports = {<br>  entry: __dirname + ‘/index.js’,<br>  output: {<br>    publicPath: ‘/‘,<br>    filename: ‘./bundle.js’<br>  },<br>  module: {<br>    loaders: [<br>      {<br>        test: /.jsx?$/,<br>        exclude: /node_modules/,<br>        loader: ‘babel’,<br>        query: {<br>          presets: [‘es2015’, ‘stage-0’, ‘react’]<br>        }<br>      },<br>      {<br>        test: /.css$/,<br>        loader: “style-loader!css-loader?modules!postcss-loader”<br>      },<br>    ]<br>  },<br>  postcss: [<br>    values<br>  ]<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接着，在colors.css里面定义变量</span><br></pre></td></tr></table></figure></p>
<p>@value blue: #0c77f8;<br>@value red: #ff0000;<br>@value green: #aaf200;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App.css可以引用这些变量</span><br></pre></td></tr></table></figure></p>
<p>@value colors: “./colors.css”;<br>@value blue, red, green from colors;</p>
<p>.title {<br>  color: red;<br>  background-color: blue;<br>}<br><code>`</code></p>
<h3 id="table布局的优缺点"><a href="#table布局的优缺点" class="headerlink" title="table布局的优缺点"></a>table布局的优缺点</h3><p>缺点  </p>
<ol>
<li>table比其他html标记占更多的字节（造成下载时间延迟，占用服务器更多流量资源）</li>
<li>table会阻挡浏览器渲染引擎的渲染顺序。（会延迟页面的生成速度，让用户等待更久的时间）</li>
<li>table里面显示图片需要你把单个、有逻辑的图片切成多个图。（增加设计的复杂度，增加页面加载时间，增加http会话数）</li>
<li>限制页面设计的自由性</li>
<li>table对于页面布局来说，从语义上看是不正确的。（它描述的是表现，而不是内容）</li>
<li>不但无法利用css，而且阅读繁琐，尤其是在进行页面改版或内容抽取的时候。</li>
<li>table一旦设计完成就变成死的，很难通过css让它展现新的面貌  </li>
</ol>
<p>优点</p>
<ol>
<li>用table做表格</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KIRIN</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KIRIN</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
