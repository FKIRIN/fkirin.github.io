<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KIRIN&#39;S blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="KIRIN&#39;S blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KIRIN&#39;S blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>KIRIN'S blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KIRIN'S blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/hexo+github搭建自己的个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/hexo+github搭建自己的个人博客/" itemprop="url">hexo+github搭建自己的个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:37+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><ul>
<li><p>安装node(mac为例)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">node -v (是否安装成功)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装git  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果上述步骤都没有问题，说明本地配置已经搞定，然后就可以在github上搭建项目了。</p>
<h2 id="github上创建并设置仓库"><a href="#github上创建并设置仓库" class="headerlink" title="github上创建并设置仓库"></a>github上创建并设置仓库</h2><p>新建仓库，在repository下填写你要创建的地址，这个地址就是你的域名，以我仓库为例，fkrin.github.io，<strong><em>一定要以xxx.github.io为结尾命名项目</em></strong>。创建完之后，点击setting设置仓库，找到Github Pages点击change theme选择主题并设置模版。</p>
<h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><ul>
<li>首先将项目clone下来<br><code>https://github.com/FKIRIN/fkirin.github.io.git</code></li>
<li>然后cd进入到项目根目录<br><code>cd fkirin.github.io</code></li>
<li><p>然后进行hexo初始化的相关命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s(启动项目，默认在4000端口)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在地址栏中输入localhost：4000可以看到这样的默认页面<img src="/images/2019-3/2019-03-19.jpg" alt="显示"></p>
</li>
<li><p>使用其他主题（以next为例）<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>然后配置_config.yml,将theme改为使用next，注意:有个空格<img src="/images/2019-3/2019-03-19-1.jpg" alt="显示">，<br>其他配置：  </p>
<ol>
<li>title: 网站标题</li>
<li>subtitle: 副标题</li>
<li>description: 个人签名</li>
<li>author: 姓名</li>
<li>language: zh-Hans<br>配置deploy的参数，参考上图。不能遗漏。</li>
</ol>
</li>
</ul>
<h2 id="提交项目部署"><a href="#提交项目部署" class="headerlink" title="提交项目部署"></a>提交项目部署</h2><ul>
<li>如果想要新增文章需要使用<br><code>hexo new &quot;名称&quot;</code>来新增md文件，否则无法识别。</li>
<li>安装部署工具<br><code>npm install hexo-deployer-git --save</code></li>
<li>移除子模块<br>因为next主题是其他仓库的内容，相当于本仓库的一个子模块，所以需要删除这个子模块将其当作此项目的一部分内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">step1: </span><br><span class="line">$ git rm --cached themes/next</span><br><span class="line">rm &apos;themes/next&apos;</span><br><span class="line">step2: </span><br><span class="line">$ git add themes/next/</span><br><span class="line">注意： 这里next之后一定要加上/，表示将这个文件夹加入，而不是将这个文件夹当作一个子模块。</span><br><span class="line">step3: </span><br><span class="line">$ git commit -m &quot;提交信息&quot;</span><br><span class="line">$ git push origin master </span><br><span class="line">step4: </span><br><span class="line">$ hexo g （刷新）</span><br><span class="line">$ hexo d  （部署）</span><br><span class="line">（如果不执行这两个命令，网页上的内容不会更新)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考： <a href="https://upupming.site/2018/05/31/git-submodules/#%E4%BB%93%E5%BA%93%E5%86%85%E5%85%8B%E9%9A%86%E5%85%B6%E4%BB%96%E4%BB%93%E5%BA%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">仓库内克隆其他仓库遇到的问题</a><br>此处是直接以master分支开发的，具体可以新起一个dev分支，通过merge dev分支来更新master上的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/vue阅读心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/vue阅读心得/" itemprop="url">vue阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:37+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue基础知识"><a href="#vue基础知识" class="headerlink" title="vue基础知识"></a>vue基础知识</h2><h3 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h3><p><strong>实例被创建时data中存在的属性才是相应式的</strong>，<br>通过使用Object.freeze()会阻止修改现有的属性，也意味着响应系统无法再追踪变化。</p>
<h4 id="指令：是带有v-前缀的特殊特性。指令的指责是当表达式的值改变时，将其产生的连带影响响应式作用于DOM"><a href="#指令：是带有v-前缀的特殊特性。指令的指责是当表达式的值改变时，将其产生的连带影响响应式作用于DOM" class="headerlink" title="指令：是带有v-前缀的特殊特性。指令的指责是当表达式的值改变时，将其产生的连带影响响应式作用于DOM"></a>指令：是带有v-前缀的特殊特性。指令的指责是当表达式的值改变时，将其产生的连带影响响应式作用于DOM</h4><h4 id="常用指令缩写"><a href="#常用指令缩写" class="headerlink" title="常用指令缩写"></a>常用指令缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v-bind 的缩写</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line">v-on 的缩写</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性缓存法的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &apos;message&apos;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">     reversedMessage: function() &#123;</span><br><span class="line">         return this.message.split(&apos;&apos;).reverse.join(&apos;&apos;)</span><br><span class="line">     &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  methods: &#123;</span><br><span class="line">      reversedMesaage: function() &#123;</span><br><span class="line">          return this.message.split(&apos;&apos;).reverse.join(&apos;&apos;) </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们可以将同一个函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的。不同的是<strong>计算属性是基于他们的依赖进行缓存的</strong>，只要相关依赖发生改变时它们才会重新求值。</p>
<h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器，这就是为什么通过watch选项提供了一个更通用的方法来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式时最有用的。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ul>
<li>不推荐同时使用v-if和v-for。</li>
<li>当v-if与v-for一起使用时，v-for具有比v-if更高的优先级。</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[1] = &apos;x&apos; // 不是响应性的</span><br><span class="line">vm.items.length = 2 // 不是响应性的</span><br></pre></td></tr></table></figure>
<p>可以通过Vue.set方法<code>Vue.set(vm.items, indexOfItem, newValue)</code>也可以使用vm.$set实例方法<code>vm.$set(vm.items, indexOfItem, newValue)</code>。对象方法同样如此。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>有时也需要在内联语句处理器中访问原始的DOM事件。可以用特殊变量$event把它传入方法<br><code>&lt;button v-on:click=&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;
  Submit
&lt;/button&gt;</code></p>
<ul>
<li>事件修饰符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul>
<li>插槽可以类比与react的this.props.children属性。</li>
<li>插槽的name属性相当于一个key用来匹配填写插槽内容<br>插槽的作用域限制： 父组件模版的所有东西都会在父级作用域内编译；子组件模版的所有东西都会在子级作用域内编译。</li>
</ul>
<h3 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h3><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>provide 和 inject类比react的context属性，组件跨级之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 顶级组件声明</span><br><span class="line">provide: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        getMap: this.getMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 后代组件使用</span><br><span class="line">inject: [&apos;getMap&apos;]</span><br></pre></td></tr></table></figure>
<p>相比$parent属性，这个用法可以让我们在任意后代组件中访问getMap属性，而不需要暴露整个组件实例。可以把依赖注入看作一部分大范围有效的prop。</p>
<p>依赖注入是存在负面影响的，将目前的组件耦合了起来，使重构变得更加困难，<strong>同时所提供的属性是非响应式的。</strong></p>
<h2 id="vuex数据管理"><a href="#vuex数据管理" class="headerlink" title="vuex数据管理"></a>vuex数据管理</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>vuex的状态存储是响应式的，从store实例中读取状态最简单的就是在计算属性中返回某个状态。<br>组件中获取vuex的状态：vuex通过store选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（Vue.use(Vuex),子组件通过this.$store访问。</p>
<ul>
<li>mapState辅助函数 </li>
</ul>
<p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，可以使用mapState辅助函数帮我我们生成计算属性。</p>
<h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p>getter会暴露为store.getters对象，getter可以通过属性和方法访问, <strong> </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 属性访问</span><br><span class="line">getters: &#123;</span><br><span class="line">    donTodoCount: (state, getters) =&gt; &#123;</span><br><span class="line">        return getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件中使用</span><br><span class="line">computed: &#123;</span><br><span class="line">   donTodoCount() &#123;</span><br><span class="line">       return this.$store.getters.doneTodosCount</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">// 方法访问</span><br><span class="line">getters: &#123;</span><br><span class="line">    getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class="line">        return state.todos.find(todo =&gt; todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.getters.getTodoById(2)</span><br></pre></td></tr></table></figure></p>
<h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">        &apos;doneTodoCount&apos;,</span><br><span class="line">        &apos;anotherGetter&apos;,</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h3><p>更改Vuex的store中的状态的唯一方法是提交mutation，每个mutation都有一个字符串类型的事件类型（type）和一个回调函数（handler）。</p>
<p><strong>mutation必须是同步函数</strong></p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul>
<li>action提交的是mutation，而不是直接变更状态</li>
<li>action可以包含任意异步操作。</li>
</ul>
<p>store.dispatch可以处理被触发的action的处理函数返回的Promise,并且store.dispatch仍旧返回Promise.</p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，store对象变得臃肿，因为vuex允许我们将store分割成模块，每个模块有自己的state、mutation、action、getter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">const moduleB = &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">const store = new Vuex.store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/基础知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KIRIN">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KIRIN'S blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/基础知识总结/" itemprop="url">基础知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-15T09:48:09+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>react将真实DOM抽象为虚拟DOM，然后通过新旧虚拟DOM这两个对象的差异(Diff算法)，最终将变化的部分重新渲染，提高效率。<br>虚拟dom算法：<br>1.用javascript对象表示DOM树的结构，然后用这个树构建一个真正的DOM树，插到文档中。<br>2.当状态变更的时候，重新构造一颗新的对象树，然后用对比新旧树，记录差异。<br>3.把记录的差异用到步骤1构建的真实DOM树，更新视图<br>一句话： 用js对象的形式来表示一颗真实的DOM树。</p>
<h3 id="react何时同步更新state"><a href="#react何时同步更新state" class="headerlink" title="react何时同步更新state"></a>react何时同步更新state</h3><ul>
<li>通过添加addEventLister来同步更新state</li>
<li>通过setTimeOut来同步更新state<br>原理： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。<br><a href="https://zhuanlan.zhihu.com/p/26069727" target="_blank" rel="noopener">react同步更新state</a></li>
</ul>
<h3 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h3><p><img src="/images/2019-5/23.png" alt="周期运行图片">  </p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><ul>
<li><p>设置组件的默认属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static defaultProps = &#123;</span><br><span class="line">  name: &apos;kk&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置组件的初始化状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">  super(); // 用于访问和调用一个对象的父对象上的函数</span><br><span class="line">  this.state = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>componentWillMount()<br>组件即将被渲染到页面之前触发，此时可以开启定时器操作</p>
</li>
<li><p>render()<br>组件渲染</p>
</li>
<li><p>componentDidMount()<br>组件已经被渲染到页面触发：此时页面中有了真正的DOM的元素，可以进行DOM相关操作</p>
</li>
</ul>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><ul>
<li><p>componentWillReceiveProps()<br>组件接收到属性时触发</p>
</li>
<li><p>shouldComponentUpdate()<br>当组件接收到新属性，或者组件的状态发生改变时触发，组件首次渲染时不会触发，返回boolean值。常用来优化性能。</p>
</li>
</ul>
<p>react项目需要更新一个组件时，很可能需要父组件更新自己的状态，而一个父组件的重新更新会造成它所有子组件重新执行render方法，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染。react中提供了PureComponent的类，当我们的组件继承它的时候，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。（PureComponet进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组）。</p>
<ul>
<li><p>componentWillUpdate<br>组件即将被更新时触发</p>
</li>
<li><p>componentDidUpdate<br>组件被更新完成后触发，页面中产生了新的DOM的元素，可以进行DOM操作</p>
</li>
</ul>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><ul>
<li>componentWillUnmount<br>组件被销毁时触发，这里可以进行一些清理操作，清理定时器，取消redux的订阅事件等等。</li>
</ul>
<h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><ol>
<li>react hooks要解决的问题是状态共享，是继render-props和higher-order components之后的第三种状态共享方案，不会产生JSX嵌套地狱问题。状态共享可能描述的不是很恰当，状态逻辑复用，因为只共享数据处理逻辑，不会共享数据本身。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Toggle initial=&#123;false&#125;&gt;</span><br><span class="line">      &#123;(&#123; on, toggle &#125;) =&gt; (</span><br><span class="line">        &lt;Button type=&quot;primary&quot; onClick=&#123;toggle&#125;&gt; Open Modal &lt;/Button&gt;</span><br><span class="line">        &lt;Modal visible=&#123;on&#125; onOk=&#123;toggle&#125; onCancel=&#123;toggle&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Toggle&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>react hooks解决的也是这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [open, setOpen] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; setOpen(true)&#125;&gt;</span><br><span class="line">        Open Modal</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Modal</span><br><span class="line">        visible=&#123;open&#125;</span><br><span class="line">        onOk=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">        onCancel=&#123;() =&gt; setOpen(false)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比,<br><strong><em>这个组件是没有状态的</em></strong>。</p>
<ol start="2">
<li>特性： </li>
</ol>
<ul>
<li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ul>
<ol start="3">
<li>hooks带来的约定<br>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。<br>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。<br>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。<br><a href="https://juejin.im/post/5be8d3def265da611a476231" target="_blank" rel="noopener">参考</a></li>
</ol>
<h3 id="super作用："><a href="#super作用：" class="headerlink" title="super作用："></a>super作用：</h3><ol>
<li>初始化构造函数</li>
</ol>
<h3 id="keys作用："><a href="#keys作用：" class="headerlink" title="keys作用："></a>keys作用：</h3><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<h3 id="setState工作原理"><a href="#setState工作原理" class="headerlink" title="setState工作原理"></a>setState工作原理</h3><p>setState是通过一个队列机制异步更新state，当执行setState时，会将需要更新的state合并后放入状态队列，而不会立刻更新state，队列机制可以高效地批量更新state。</p>
<p>在代码中调用setState函数之后，react会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程，经过调和过程，react会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。react在得到元素树之后，react会自动计算出新的树与老树的节点差异，然后根据差异对界面进行局部更新重渲染。<br><a href="https://zhuanlan.zhihu.com/p/20328570?columnSlug=purerender" target="_blank" rel="noopener">详解</a></p>
<h3 id="Element与Component的区别"><a href="#Element与Component的区别" class="headerlink" title="Element与Component的区别"></a>Element与Component的区别</h3><p>Element是描述屏幕上所见内容的数据结构，是对于UI的对象表述。典型的React Element就是利用JSX构建的声明式代码片然后被转化为createElement的调用组合，而Component则是可以接收参数输入并且返回某个React Element的函数或者类。</p>
<h3 id="为什么需要使用React提供的Children-API而不是Javascript的map？"><a href="#为什么需要使用React提供的Children-API而不是Javascript的map？" class="headerlink" title="为什么需要使用React提供的Children API而不是Javascript的map？"></a>为什么需要使用React提供的Children API而不是Javascript的map？</h3><p>props.children获取到的内容可能是object也可能是array,React.Children.map已经将props.children不同类型的情况考虑在内了。</p>
<h3 id="setState函数的第二个参数的作用是什么？"><a href="#setState函数的第二个参数的作用是什么？" class="headerlink" title="setState函数的第二个参数的作用是什么？"></a>setState函数的第二个参数的作用是什么？</h3><p>该函数会在setState函数调用完成并且组件开始重新渲染的时候被调用，我们可以用该函数来监听渲染是否完成。</p>
<h3 id="react组件类型"><a href="#react组件类型" class="headerlink" title="react组件类型"></a>react组件类型</h3><ul>
<li><p>SFC(Stateless Functional Component)<br>React可以使用Function来创建Component，这类Component没有lifecycle，内部不维护state，只要传入的props有变化则进行重新渲染。</p>
</li>
<li><p>HOC(Higher-Order Components)<br>高阶组件就是一个方法，传入一个组件返回另一个组件。最常见的是react-redux里的connect方法，通过传入组件和map*ToProps方法，让组件和store连接。组件内部就可以直接通过props获得connect之后的值。</p>
</li>
</ul>
<p><strong>高阶组件不要在render中使用另外一个HOC</strong>，会严重影响性能问题（重新挂载组件会导致该组件及其所有子组件的状态丢失。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps,</span><br><span class="line">)(Component);</span><br></pre></td></tr></table></figure></p>
<p>高阶组件适合用来扩展功能，把这部分功能从业务组件中抽离出来，需要的套上，不需要的时候移除，对被包裹组件侵入性非常小</p>
<ul>
<li>Dynamic Component<br>在执行时才能确定具体的标签或者组件是什么<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const &#123; tag: Tag, children &#125; = this.props;</span><br><span class="line">    return &lt;Tag&gt;&#123; children &#125;&lt;/Tag&gt;</span><br><span class="line">&#125;</span><br><span class="line">```setState</span><br><span class="line"></span><br><span class="line">- FaCC(Functions as Child Componets)</span><br><span class="line">React children可以是Function类型，封装一个loading组件，会给children提供loading参数，业务组件贼根据loading判断需要render什么内容</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>class LoadArea extends Component {<br>  state = {<br>    loading: true,<br>  };</p>
<p>  componentDidMount() {<br>    asyncFunc()<br>        .then(() =&gt; {<br>            this.setState({<br>              loading: false,<br>            })<br>        })<br>        .catch(() =&gt; {<br>            this.setState({<br>              loading: false,<br>            })<br>        })<br>  }</p>
<p>  render() {<br>    return (<br>      &lt;React.Fragment&gt;<br>        {this.props.children({<br>          …this.props,<br>          …this.state,<br>        })}<br>      &lt;/React.Fragment&gt;<br>    );<br>  }<br>}</p>
<hr>
<p>render() {<br>    <loadingarea><br>        ({ loading }) =&gt; {<br>            loading<br>                ? <wating><br>                : <main><br>        }<br>    </main></wating></loadingarea><br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Javascript概念</span><br><span class="line">### js微任务/宏任务  </span><br><span class="line">synchronous： 同步任务  </span><br><span class="line">asynchronous：异步任务  </span><br><span class="line">tast queue/callback queue： 任务队列  </span><br><span class="line">execution context stack： 执行栈  </span><br><span class="line">heap： 堆  </span><br><span class="line">stack： 栈  </span><br><span class="line">macro-task： 宏任务  </span><br><span class="line">micro-task： 微任务  </span><br><span class="line">1. js是单线程，将任务分为同步任务和异步任务。一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，结果不过是在执行栈中再添加一个执行环境，这个过程可以是无限进行下去的，除非发生了栈溢出。  </span><br><span class="line">2. 同步和异步任务分别进入不同的执行场所，同步的进入主线程，异步的进入event table并注册函数。当指定的事情完成时，event table会将这个函数移入event queue。主线程内的任务执行完毕为空，会去event queue读取对应的函数，进入主线程执行。上述过程不断重复，也就是常说的Event Loop（事件循环）</span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
<p>let data = [];<br>$.ajax({<br>    url:<a href="http://www.javascript.com" target="_blank" rel="noopener">www.javascript.com</a>,<br>    data:data,<br>    success:() =&gt; {<br>        console.log(‘发送成功!’);<br>    }<br>})<br>console.log(‘代码执行结束’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">一段简易的ajax请求代码，ajax进入event table，注册回调函数success。执行console.log（&apos;代码执行结束&apos;）。ajax事件完成，回调函数success进入event queue。主线程从event queue读取回调函数success并执行。</span><br><span class="line"></span><br><span class="line">4. 微任务、宏任务  </span><br><span class="line">微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于它们的执行顺序，event loop的走向和取值。  </span><br><span class="line">js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后在执行微任务，将微任务放入event queue。当你往外拿的时候先从微任务手里拿回调函数，然后再从宏任务的queue上拿宏任务的回调函数。  </span><br><span class="line">宏任务一般： 包括整体代码script, setTimeout, setInterval, setImmediate.  </span><br><span class="line">微任务： 原生Promise（有些实现的promise 将then方法放到了宏任务中）、process.nextTick、MutaionObserver、Object.observer(已废弃)  </span><br><span class="line"></span><br><span class="line">参考： [微任务/宏任务详解](https://juejin.im/post/5b498d245188251b193d4059)</span><br><span class="line"></span><br><span class="line">### DOMContentLoaded/Load事件</span><br><span class="line">结合DOM文档加载的加载步骤，DOMContentLoaded事件/Load事件，触发时机如下：  </span><br><span class="line"></span><br><span class="line">1. 解析HTMl结构</span><br><span class="line">2. 加载外部脚本和样式文件。</span><br><span class="line">3. 解析并执行脚本代码。 // 部分脚本会阻塞页面的加载</span><br><span class="line">4. DOM树构建完成。 // DOMContentLoaded事件</span><br><span class="line">5. 加载图片等外部文件。</span><br><span class="line">6. 页面加载完毕。 // load事件</span><br><span class="line"></span><br><span class="line">### js数组方法</span><br><span class="line">- slice方法返回从该为参数指定位置开始到当前数组末尾的所有项。如果两个参数，该方法返回起始位置和结束位置之间的项但不包括结束位置的项。***该方法不会影响愿数组***</span><br><span class="line">- splice最强大的数组方法：</span><br><span class="line">   </span><br><span class="line">   1. 可以删除任意数量的项，只需指定 2 个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项</span><br><span class="line">   2. 插入:可以向指定位置插入任意数量的项，只需提供 3 个参数:起始位置、0(要删除的项数) 和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如， splice(2,0,&quot;red&quot;,&quot;green&quot;)会从当前数组的位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;。</span><br><span class="line">   3. 替换:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,&quot;red&quot;,&quot;green&quot;)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 &quot;red&quot;和&quot;green&quot;。</span><br><span class="line"></span><br><span class="line">   splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)</span><br><span class="line">- every和some  </span><br><span class="line">   1. 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true   </span><br><span class="line">   2. 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</span><br><span class="line">- reduce 遍历数组中的所有项并返回一个最终值。方法接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</span><br><span class="line"></span><br><span class="line">### _proto_和prototype的区别和关系  </span><br><span class="line">首先贴上关键图片: ![原型图](/images/2019-3/2019-03-20.jpg)  </span><br><span class="line">1. 方法（Function）是对象，方法的原型（Function.prototype）是对象。因此就具有对象共有的特点，即：对象具有属性_proto_可称为隐式原型，一个对象的隐式原型指向**构造该对象的构造函数的原型**，这就保证了实例能够访问在构造函数原型中定义的属性和方法。</span><br><span class="line">2. 方法（Function）是个特殊的对象，除了具有_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象有属性constructor,这个属性包含了一个指针，指回原构造函数。  </span><br><span class="line"></span><br><span class="line">总结： </span><br><span class="line"></span><br><span class="line">1. 对象具有属性_proto_，**指向该对象的构造函数的原型对象**，Object.prototype的_proto_属性指向null。</span><br><span class="line">2. 方法除了有属性_proto_，还有属性prototype,prototype指向该方法的原型对象。</span><br><span class="line"></span><br><span class="line">### 箭头函数</span><br><span class="line"></span><br><span class="line">- 避免使用  </span><br><span class="line">箭头函数会将调用指向当前对象，不会使用的场景就是构造函数的创建，因为会希望函数指向构造函数的原型。</span><br><span class="line"></span><br><span class="line">#### new运算符</span><br></pre></td></tr></table></figure>
<p>var obj  = {};<br>obj.<strong>proto</strong> = F.prototype;<br>F.call(obj);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">以new运算符调用构造函数的时候，函数内部实际上发生以下变化：</span><br><span class="line">1. 创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。</span><br><span class="line">2. 属性和方法被加入到this引用的对象中</span><br><span class="line">3. 新创建的对象由this所引用，并且最后隐式的返回this</span><br><span class="line"></span><br><span class="line">[详解原型链](https://juejin.im/post/58f94c9bb123db411953691b)</span><br><span class="line"></span><br><span class="line">### 算法</span><br><span class="line">- 计数排序的思想  </span><br><span class="line">  1. 首先会对每个输入进行频率统计，得到元素的频率表；</span><br><span class="line">  2. 然后将频率表转换为该元素的开始索引；</span><br><span class="line">  3. 根据各个元素的开始索引，将相同元素分类到临时数组中。</span><br><span class="line">  4. 最后将临时数组中的元素写回到原数组中。</span><br><span class="line"></span><br><span class="line">- 桶排序的思想  </span><br><span class="line">  1. 根据输入建立适当个数的桶，每个桶可以存放某个范围内的元素；</span><br><span class="line">  2. 将落在特定范围内的所有元素放入对应的桶中；</span><br><span class="line">  3. 对每个非空的桶中元素进行排序，可以选择通用的排序方法，比如插入、快排</span><br><span class="line">  4. 按照划分的范围顺序，将桶中的元素依次取出。排序完成。</span><br><span class="line"></span><br><span class="line">- 基数排序</span><br><span class="line">  基数排序按照从右往左的顺序，依次将每一位都当作一次关键字，然后按照关键字对数组排序，每一轮排序都基于上轮排序后的结果。最后一轮，最左边那位也作为关键字并排序，整个数组就达到有序状态。</span><br><span class="line"></span><br><span class="line">  [参考](https://www.cnblogs.com/sun-haiyu/p/7859252.html)</span><br><span class="line"></span><br><span class="line">### 防抖与节流</span><br><span class="line">- 防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</span><br></pre></td></tr></table></figure></p>
<p>window.onload = function() {<br>      // 1、获取这个按钮，并绑定事件<br>      var myDebounce = document.getElementById(“debounce”);<br>      myDebounce.addEventListener(“click”, debounce(sayDebounce));<br>    }</p>
<pre><code>// 2、防抖功能函数，接受传参
function debounce(fn) {
  // 4、创建一个标记用来存放定时器的返回值
  let timeout = null;
  return function() {
    // 5、每次当用户点击/输入的时候，把前一个定时器清除
    clearTimeout(timeout);
    // 6、然后创建一个新的 setTimeout，
    // 这样就能保证点击按钮后的 interval 间隔内
    // 如果用户还点击了的话，就不会执行 fn 函数
    timeout = setTimeout(() =&gt; {
      fn.call(this, arguments);
    }, 1000);
  };
}

// 3、需要进行防抖的事件处理
function sayDebounce() {
  // ... 有些需要防抖的工作，在这里执行
  console.log(&quot;防抖成功！&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 节流: 指定时间间隔内只会执行一次任务</span><br></pre></td></tr></table></figure>
<p>window.onload = function() {<br>      // 1、获取按钮，绑定点击事件<br>      var myThrottle = document.getElementById(“throttle”);<br>      myThrottle.addEventListener(“click”, throttle(sayThrottle));<br>    }</p>
<pre><code>// 2、节流函数体
function throttle(fn) {
  // 4、通过闭包保存一个标记
  let canRun = true;
  return function() {
    // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
    if(!canRun) {
      return;
    }
    // 6、将 canRun 设置为 false，防止执行之前再被执行
    canRun = false;
    // 7、定时器
    setTimeout( () =&gt; {
      fn.call(this, arguments);
      // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
      canRun = true;
    }, 1000);
  };
}

// 3、需要节流的事件
function sayThrottle() {
  console.log(&quot;节流成功！&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 重绘与回流（重排</span><br><span class="line">- 重绘（repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，由于只需要UI层面的重新像素绘制，因此损耗较少。常见的重绘操作有：  </span><br><span class="line">  </span><br><span class="line">  1. 改变元素颜色</span><br><span class="line">  2. 改变元素背景色</span><br><span class="line">  3. more。。。</span><br><span class="line">- 回流（reflow): 又叫重排。当元素的尺寸、结构或者触发某些属性时，浏览器会重新刷新页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此时较重的操作。常见的回流操作有：</span><br><span class="line"></span><br><span class="line">  1. 页面初次渲染</span><br><span class="line">  2. 浏览器窗口大小改变</span><br><span class="line">  3. 元素尺寸/位置/内容发生改变</span><br><span class="line">  4. 元素字体大小变化</span><br><span class="line">  5. 添加或者删除可见的DOM元素</span><br><span class="line">  6. 激活CSS伪类</span><br><span class="line">  7. more。。。</span><br><span class="line"></span><br><span class="line">**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高**  </span><br><span class="line">为什么需要节流？ 因为有些事情会造成浏览器的回流，而回流会使浏览器的开销增大，所以通过节流来防止增大浏览器开销的事情。  </span><br><span class="line">如何避免大量使用重绘与回流呢？</span><br><span class="line"></span><br><span class="line">1. 避免频繁操作样式，可汇总后统一一次修改</span><br><span class="line">2. 尽量使用class进行样式修改，而不是直接操作样式</span><br><span class="line">3. 减少DOM的操作，可使用字符串一次性插入</span><br><span class="line"></span><br><span class="line">### js冻结对象</span><br><span class="line">1. Object.freeze() 冻结一个对象：</span><br><span class="line"> - 不能向这个对象添加新属性  </span><br><span class="line"> - 不能修改其已有属性的值  </span><br><span class="line"> - 不能删除已有属性  </span><br><span class="line"> - 不能修改该对象已有属性的可枚举性、可配置性、可写性</span><br><span class="line"></span><br><span class="line">### 函数</span><br><span class="line">1. arguments.callee是为了实现函数更松散的耦合，最简单的实例，函数的递归调用</span><br></pre></td></tr></table></figure>
<p>function factorial(num){<br>    if (num &lt;=1) {<br>        return 1;<br>    } else {<br>        return num * arguments.callee(num-1)<br>} }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2. 函数的属性length和prototype，length属性表示函数希望接收的命名参数的个数。</span><br><span class="line"></span><br><span class="line">### 字符串</span><br><span class="line">1. charAt 返回字符串的位置</span><br><span class="line">2. charCodeAt 返回字符串的字符编码</span><br><span class="line">3. concat 用于字符串的拼接</span><br><span class="line">4. slice，substr，sbustring用来获取字符串，不会修改原有字符串返回新的字符串</span><br><span class="line">5. trim方法用来去除字符串的空格，返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变</span><br><span class="line">6. localeCompare 比较两个字符串，返回 -1， 0，1。</span><br></pre></td></tr></table></figure></p>
<p>var stringValue = “yellow”; alert(stringValue.localeCompare(“brick”)); //1 alert(stringValue.localeCompare(“yellow”)); //0 alert(stringValue.localeCompare(“zoo”)); //-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 对象</span><br><span class="line">- object.defineProperty这个方法 接收三个参数:属性所在的对象、属性的名字和一个描述符对象（必须设置configurable、enumerable、writable 和 value其中的一个值或多个值）。</span><br><span class="line"></span><br><span class="line">-  hasOwnProperty()方法可以检测一个属性是存在于实例中</span><br><span class="line"></span><br><span class="line">### 柯里化 </span><br><span class="line">为实现多参函数提供了一个递归降解的实现思路---把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数。</span><br><span class="line"></span><br><span class="line">### 闭包</span><br><span class="line">1. 可以读取函数内部的变量。</span><br><span class="line">2. 让这些变量的值始终保持在内存中。</span><br><span class="line">弊端： 占用内存，慎用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 装饰器</span><br></pre></td></tr></table></figure></p>
<p>class Cat() {<br>  say() {<br>    console.log(“meow ~”)<br>  }<br>}</p>
<p>function Cat() {<br>  Object.defineProperty(Cat.proptotype, “say”, {<br>    value: function() { console.log(“meow ~”) },<br>    enumerable: false,<br>    configurable: true,<br>    writable: true<br>  });</p>
<h2 id><a href="#" class="headerlink" title="}"></a>}</h2><p>function readonly(target, name, desciptor) {<br>  desciptor.writable = false;<br>  return descriptor<br>}</p>
<p>class Cat {<br>  @readonly<br>  say() {<br>    console.log(“meow `”);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由此可以看出作用于类的属性的时候的装饰器函数接收的参数就是上述ES6中的类定义属性时候使用Object.defineProperty时接收的参数是一样的。</span><br><span class="line"></span><br><span class="line">***本质上也就是说装饰器在作用于类的属性的时候，实际上是通过Object.defineProperty***  </span><br><span class="line">装饰一个类：  </span><br><span class="line">装饰一个类的时候本身本质上是一个函数，没有descriptor，target是这个函数本身。</span><br></pre></td></tr></table></figure></p>
<p>function isAnimal(target) {<br>    target.isAnimal = true;<br>      return target;<br>}<br>@isAnimal<br>class Cat {<br>    …<br>}<br>console.log(Cat.isAnimal);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">也就是说，上面的@isAnimal其实就是做了下面这件事：  </span><br><span class="line">`Cat = isAnimal(function Cat() &#123; ... &#125;);` </span><br><span class="line"></span><br><span class="line">### DOM</span><br><span class="line"></span><br><span class="line">操作节点： </span><br><span class="line"></span><br><span class="line">1. appendChild: 向childNodes列表的末尾添加一个节点</span><br><span class="line">2. insertBefore: 这个方法要接收两个参数，要插入的节点和作为参照的节点，吐过参照节点是null，则insertBefore与appendChild执行相同的操作</span><br><span class="line">3. replaceChild: 方法接收的两个参数是要插入的节点和要替换的节点</span><br><span class="line">4. removeChild: 接受一个参数即要移除的节点</span><br><span class="line">5. cloneNode: 创建这个节点完全相同的副本，该方法接受一个boolean值参数，表示是否执行深复制，true执行深复制，也就是复制节点及其整个子节点树。</span><br><span class="line"></span><br><span class="line">查找元素: </span><br><span class="line"></span><br><span class="line">1. getElementById</span><br><span class="line">2. getElementsByTagName: 接受元素的标签名，返回的包含0或者多个元素的NodeList。</span><br><span class="line">3. getElementsByName: 这个方法返回带有给定name特性的所有元素</span><br><span class="line">4. querySelector: 接受一个css选择符，返回与该模式匹配的第一个元素,没有返回null。</span><br><span class="line">5. querySelectorAll: 接受一个css选择符，返回Nodelist的实例。</span><br><span class="line">6. matchesSelector: 接受一个选择符，如果调用元素与该元素匹配返回true否则false</span><br><span class="line">7. getElementsByClassName: 接受一个包含一个或多个类名的字符串，返回带有指定类的所有元素的NodeList</span><br><span class="line">8. DOMTokenList: 为所有元素添加classList属性，这个classList属性是新集合DOMTokenList的实例。含有4个属性，add——将给定的字符串添加到列表中，如果已经存在则不添加;contains——表示列表中是否存在给定的值，如果存在则返回true,否则返回false;remove——从列表中删除给定的字符串;toggle——如果列表中已经存在给定的值，删除它，如果没有给定的值，添加它。</span><br><span class="line"></span><br><span class="line">创建元素</span><br><span class="line"></span><br><span class="line">1. document.createElement: 接受一个参数即要创建元素的标签名</span><br><span class="line">2. document.createTextNode: 创建新文本节点，接受一个参数插入节点中的文本。</span><br><span class="line">3. documentFragment.createDocumentFragment: DocumentFragment在文档中没有对应的标记，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。虽然不能把文档片段直接添加到文档中，但是可以将它作为“仓库”来使用，即在里面保存将来可能会添加到文档中的节点。</span><br></pre></td></tr></table></figure></p>
<p>var fragment = document.createDocumentFragment();<br>    var ul = document.getElementById(“myList”);<br>    var li = null;<br>    for (var i=0; i &lt; 3; i++){<br>        li = document.createElement(“li”);<br>        li.appendChild(document.createTextNode(“Item “ + (i+1)));<br>        fragment.appendChild(li);<br>    }<br>    ul.appendChild(fragment);<br>    // 一次性放入也有利于提升性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 焦点管理  </span><br><span class="line">document.activeElement属性始终引用DOM中当前获得来焦点的元素，元素获得焦点的方式有页面加载、用户输入和在代码中调用focus()方法，document.hasFocus勇于确定文档是否获得了焦点。</span><br><span class="line"></span><br><span class="line">- scrollIntoView  </span><br><span class="line">document.forms[0].scrollIntoView通过浏览器窗口或某个容器元素，调用就可以出现在视口中。</span><br><span class="line"></span><br><span class="line">- 事件处理程序  </span><br><span class="line">DOM2级事件，addEventListener和removeEventListener接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。布尔值参数为true表示在捕获阶段调用事件处理程序；如果是false表示在冒泡阶段调用事件处理程序。  </span><br><span class="line">移除的事件处理函数必须与传入的addEventListener相同。</span><br></pre></td></tr></table></figure></p>
<p> var btn = document.getElementById(“myBtn”);<br>    btn.addEventListener(“click”, function(){<br>        alert(this.id);<br>    }, false);<br>//这里省略了其他代码<br>btn.removeEventListener(“click”, function(){ //没有用!<br>  alert(this.id);<br>}, false);</p>
<p>var btn = document.getElementById(“myBtn”);<br>    var handler = function(){<br>        alert(this.id);<br>    };<br>    btn.addEventListener(“click”, handler, false);<br>//这里省略了其他代码<br>btn.removeEventListener(“click”, handler, false); //有效!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 跨域</span><br><span class="line"></span><br><span class="line">- 图像ping 使用`&lt;img&gt;`标签。动态创建图像经常用于图像Ping，图像ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过 图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时 候接收到的</span><br></pre></td></tr></table></figure></p>
<p>var img = new Image();<br>img.onload = img.onerror = function(){<br>    alert(“Done!”);<br>};<br>img.src = “<a href="http://www.example.com/test?name=Nicholas&quot;" target="_blank" rel="noopener">http://www.example.com/test?name=Nicholas&quot;</a>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- JSONP  </span><br><span class="line">JSONP是JSON with padding的简写。JSONP由两部分组成：回调函数和数据。`callback(&#123; &quot;name&quot;: &quot;Nicholas&quot; &#125;)`,回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的JSON数据，如：`http://freegeoip.net/json/?callback=handleResponse`.JSONP是通过动态script元素来使用的，使用时可以为src属性指定一个跨域URL。</span><br></pre></td></tr></table></figure></p>
<p>function handleResponse(response){<br>alert(“You’re at IP address “ + response.ip + “, which is in “ +<br>          response.city + “, “ + response.region_name);<br>}<br>var script = document.createElement(“script”);<br>script.src = “<a href="http://freegeoip.net/json/?callback=handleResponse&quot;" target="_blank" rel="noopener">http://freegeoip.net/json/?callback=handleResponse&quot;</a>; document.body.insertBefore(script, document.body.firstChild);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONP的不足，从其他域中加载代码执行，安全性；确定JSONP请求是否失败并不容易，新增了一个onerror事件处理程序。</span><br><span class="line"></span><br><span class="line">### javascript高级技巧 </span><br><span class="line">- 高级函数  </span><br><span class="line">1. 安全的类型检测，javascript内置的类型检测机制并非完全可靠，比如typeof经常会导致检测数据类型时得到不靠谱的结果。解决问题的办法时统一的，通过调用Object原生的toString方法，返回[Object NativeConstructorName]格式的字符串。每个类在内部都有一个[[class]]属性。比如`Object.prototype.toString.call(value) // &quot;[object Array]&quot;`,由于原生数组的构造函数与全局作用域无关，因此使用toString方法就能保证返回统一的值。</span><br><span class="line">2. 作用域安全的构造函数  </span><br><span class="line">构造函数时通过new操作符调用的函数，当使用new调用时，构造函数内部的用到的this对象会指向新创建的对象实例</span><br></pre></td></tr></table></figure></p>
<p>var person = Person(“Nicholas”, 29, “Software Engineer”);<br>alert(window.name);<br>alert(window.age);<br>alert(window.job);<br>//“Nicholas”<br>//29<br>//“Software Engineer”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当没有使用new操作符来调用构造函数时，由于this对象是在运行时绑定的，所以直接调用Person(),this会映射到全局对象window上，所以这里对属性的偶然覆盖会导致页面上出现错误，解决方法就是创建一个作用域安全的构造函数，通过确认this对象是正确类型的实例。</span><br></pre></td></tr></table></figure></p>
<p>function Person(name, age, job){<br>        if (this instanceof Person){<br>            this.name = name;<br>            this.age = age;<br>            this.job = job;<br>        } else {<br>            return new Person(name, age, job);<br>        }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 惰性载入函数  </span><br><span class="line">因为浏览器的差异，多数JavaScript代码包含了大量if语句。</span><br></pre></td></tr></table></figure></p>
<p>function createXHR(){<br>        if (typeof XMLHttpRequest != “undefined”){<br>            return new XMLHttpRequest();<br>        } else if (typeof ActiveXObject != “undefined”){<br>            if (typeof arguments.callee.activeXString != “string”){<br>                var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                                “MSXML2.XMLHttp”],<br>i,len;<br>                for (i=0,len=versions.length; i &lt; len; i++){<br>                     try {<br>                         new ActiveXObject(versions[i]);<br>                         arguments.callee.activeXString = versions[i];<br>                          break;<br>                     } catch (ex){<br>//跳过 }<br>            return new ActiveXObject(arguments.callee.activeXString);<br>        } else {<br>            throw new Error(“No XHR object available.”);<br>        }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">惰性载入表示函数执行的分之仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调 用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任 何对原函数的调用都不用再经过执行的分支了。</span><br></pre></td></tr></table></figure></p>
<p>function createXHR(){<br>        if (typeof XMLHttpRequest != “undefined”){<br>            createXHR = function(){<br>              return new XMLHttpRequest();<br>} else if (typeof ActiveXObject != “undefined”){<br>    createXHR = function(){<br>        if (typeof arguments.callee.activeXString != “string”){<br>            var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>   i, len;<br>“MSXML2.XMLHttp”],<br>                    for (i=0,len=versions.length; i &lt; len; i++){<br>                        try {<br>                          new ActiveXObject(versions[i]);<br>                          arguments.callee.activeXString = versions[i];<br>                             break;<br>                        } catch (ex){<br>//skip }<br>} }<br>                return new ActiveXObject(arguments.callee.activeXString);<br>            };<br>} else {<br>            createXHR = function(){<br>                throw new Error(“No XHR object available.”);<br>            };<br>}<br>    return createXHR();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二种实现惰性载入的方式在声明函数时就指定适当的函数。</span><br></pre></td></tr></table></figure>
<p>var createXHR = (function(){<br> if (typeof XMLHttpRequest != “undefined”){<br>return function(){<br> } else if (typeof ActiveXObject != “undefined”){<br>    return function(){<br>        if (typeof arguments.callee.activeXString != “string”){<br>            var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                            “MSXML2.XMLHttp”],<br>            i, len;<br>        for (i=0,len=versions.length; i &lt; len; i++){<br>            try {<br>                new ActiveXObject(versions[i]);<br>                arguments.callee.activeXString = versions[i];<br>                break;<br>} catch (ex){<br>//skip }<br>}<br>}<br>    return new ActiveXObject(arguments.callee.activeXString);<br>};<br>} else {<br>        return function(){<br>            throw new Error(“No XHR object available.”);<br>        };<br>} })();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 函数绑定  </span><br><span class="line">函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。</span><br></pre></td></tr></table></figure>
<p>var handler = {<br>        message: “Event handled”,<br>        handleClick: function(event){<br>            alert(this.message);<br>} };<br>    var btn = document.getElementById(“my-btn”);<br>    EventUtil.addHandler(btn, “click”, handler.handleClick);</p>
<p>当按下按钮调用该函数，显示的时undefined，问题在与没有保存handler.handleClick的执行环境，this对象指向了DOM按钮而非handler。解决方案是通过内部使用闭包直接调用handler.handleClick。<br>EventUtil.addHandler(btn, “click”, function(event{<br>        handler.handleClick(event);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以出现了bind函数，接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。</span><br></pre></td></tr></table></figure></p>
<p>function bind(fn, context){<br>        return function(){<br>          return fn.apply(context, arguments);<br>        };<br>}</p>
<p>var handler = {<br>  message: “Event handled”,<br>  handleClick: function (event) {<br>    alert(this.message)<br>  }<br>}<br>var btn = document.getElementById(“my-btn”);<br>EventUtil.addHandler(btn, “click”, bind(handler.handleClick, handler));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ES5定义了原生的bind方法，上述案例可以这样使用。`EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler));`</span><br><span class="line"></span><br><span class="line">5. 函数柯里化  </span><br><span class="line">用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定时一致的：使用一个闭包返回一个函数。</span><br></pre></td></tr></table></figure></p>
<p> function curry(fn){<br>        var args = Array.prototype.slice.call(arguments, 1);<br>        return function(){<br>            var innerArgs = Array.prototype.slice.call(arguments);<br>            var finalArgs = args.concat(innerArgs);<br>            return fn.apply(null, finalArgs);<br>    }; }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 防篡改对象</span><br><span class="line"></span><br><span class="line">1. 不可扩展对象:  </span><br><span class="line">Object.preventExtensions()方法不能给对象添加属性和方法。虽然不能给对象添加新成员，但已有的成员丝毫不受影响，你仍然可以修改和删除已有的成员，还可以确定对象是否可以扩展。</span><br><span class="line"></span><br><span class="line">2. 密封的对象：  </span><br><span class="line">Object.seal().密封对象不可扩展，而且已有成员的[[Configurable]]特性被设置为false，意味着不能删除属性和方法，属性值是可以修改的。</span><br><span class="line"></span><br><span class="line">3. 冻结的对象：  </span><br><span class="line">Object.freeze()。冻结的对象既不可扩展又是密封的而且对象数据属性的writable特性会被设置为false。</span><br><span class="line"></span><br><span class="line">### worker </span><br><span class="line">web worker最重要的是它执行的javascript代码完全在另一个作用域，在web worker中，同样又一个全局对象和其他对象以及方法。web worker中的代码不能访问dom，也无法通过任何方式影响页面的外观。  </span><br><span class="line">web worker中的全局对象是worker对象本身，在这个特殊的全局作用域中，this和self引用的都是worker对象。为便于处理数据，web worker本身也是一个最小化的运行环境。</span><br><span class="line"></span><br><span class="line">1. 使用worker。</span><br><span class="line">`var worker = new Worker(&apos;stufftodo.js&apos;)`,然后浏览器会下载stufftodo.js,通过postMessage()方法传递消息。worker通过message和error事件与页面通信，terminate()方法可以停止worker工作。</span><br></pre></td></tr></table></figure></p>
<p>// worker内部代码<br>self.onmessage = function(event){<br>    var data = event.data;<br>//别忘了，默认的 sort()方法只比较字符串<br>data.sort(function(a, b){<br>       return a – b;<br>    });<br>    self.postMessage(data);<br>};</p>
<p>// 页面中<br>var data = [23,4,7,9,2,14,6,651,87,41,7798,24],<br>    worker = new Worker(“WebWorkerExample01.js”);<br>worker.onmessage = function(event){<br>    var data = event.data;<br>  //对排序后的数组进行操作<br>};<br>//将数组发送给 worker 排序<br>worker.postMessage(data);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 性能优化</span><br><span class="line"></span><br><span class="line">通过优化从而提高页面的加载速度：</span><br><span class="line">-  HTML优化</span><br><span class="line"></span><br><span class="line">1. 避免html中书写CSS代码，因此这样难以维护。</span><br><span class="line">2. 使用Viewport加速页面的渲染。</span><br><span class="line">3. 使用语义化标签，减少CSS代码，增加可读性和SEO。</span><br><span class="line">4. 减少标签的使用，DOM解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。</span><br><span class="line">5. 减少src、href等值为空，因为即使为空浏览器还是会发起HTTP请求</span><br><span class="line">6. 减少DNS查询的次数</span><br><span class="line"></span><br><span class="line">- CSS优化</span><br><span class="line"></span><br><span class="line">1. 优化选择器路径： 使用.c &#123;&#125;而不是.a.b.c &#123;&#125;。</span><br><span class="line">2. 选择器合并： 共同的属性内容提取出来，压缩空间和资源开销。</span><br><span class="line">3. 精确样式：使用padding-left:10px而不是padding: 0 0 0 10px。</span><br><span class="line">4. 雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。</span><br><span class="line">5. 减少通配符： .a.b * &#123;&#125;这样的选择器，根据从右到左的解析顺序会优先遍历整个DOM，性能大大损耗。</span><br><span class="line">6. 少用float： float在渲染时计算量比较大，可以使用flex布局。</span><br><span class="line">7. 为0值去单位： 增加兼容性</span><br><span class="line">8. 压缩文件大小，减少资源下载负担。</span><br><span class="line"></span><br><span class="line">- Javascript优化</span><br><span class="line"></span><br><span class="line">1. 将script标签放在body之后，避免js的执行卡住DOM的渲染，最大程度保证页面尽快的展示出来。</span><br><span class="line">2. 合并js代码：提取公共方法，进行封装或者面向对象设计</span><br><span class="line">3. CSS能做的事情，尽量不用JS来做，毕竟js的解析执行比较粗暴，而CSS效率更高。</span><br><span class="line">4. 尽可能逐条操作DOM，并预定好CSS样式，从而减少reflow或者repaint的次数。</span><br><span class="line">5. 尽可能少地创建DOM，而是在HTML和CSS中使用display:none来隐藏，按需显示。</span><br><span class="line">6. 压缩文件大小，减少资源下载负担。</span><br><span class="line"></span><br><span class="line">## ES6</span><br><span class="line">### for in和for of的区别</span><br><span class="line">1. 推荐用for in来遍历对象，for of来遍历数组</span><br><span class="line">2. for in循环出的是key， for of循环出的是value</span><br><span class="line">3. for of 不能循环普通的对象，需要通过和object.keys搭配使用</span><br></pre></td></tr></table></figure></p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HTTP</span><br><span class="line">### TCP与UDP区别</span><br><span class="line">1. TCP(Transmission Control Protocol)是面向连接的协议，也就是说，在收发数据前必须和对方建立可靠的连接。一个TCP连接需经过3次对话，断开需要经过4次</span><br><span class="line">2. UDP是一个非连接的协议，传输数据之前源端和终端不需建立连接。当他想传送数据时就简单地去抓取来自应用程序的数据，并尽可能地扔到网络上。（常用ping命令检测主机到主机之间是否可通信，就是udp的实例  </span><br><span class="line">区别：</span><br><span class="line">- 基于连接于无连接；</span><br><span class="line">- 对系统资源的要求（TCP较多，UDP较少）</span><br><span class="line">- UDP程序结构较简单</span><br><span class="line">- 流模式与数据报模式</span><br><span class="line">- TCP保证数据正确性，UDP可能丢包</span><br><span class="line">- TCP保证数据顺序，UDP不保证</span><br><span class="line"></span><br><span class="line">### TCP协议如何提高传输效率</span><br><span class="line">- 滑动窗口</span><br><span class="line">- 快重传</span><br><span class="line">- 延迟应答</span><br><span class="line">- 捎带应答</span><br><span class="line"></span><br><span class="line">### HTTP的基本优化</span><br><span class="line"></span><br><span class="line">影响一个http网络请求的因素主要有两个： 带宽和延迟。</span><br><span class="line">- 带宽：俗称网速，但是如今网络基础建设已经有了很大的提示，不再担心由带宽而影响网速。</span><br><span class="line">- 延迟： </span><br><span class="line">  - 浏览器阻塞：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能由4个连接（根据浏览器内核有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</span><br><span class="line">  - DNS查询： 浏览器需要目标服务器的ip才能建立连接，将域名解析为IP的这个系统就是DNS，通常可以利用DNS缓存结果来达到减少时间的目的。</span><br><span class="line">  - 建立连接： http是基与TCP协议的，浏览器最快也要在第三次握手时才能捎带http请求报文，达到真正的建立连接。但是这些连接无法复用会导致每次请求都经历三次握手和慢启动，三次握手在高延迟的场景下影响明显，慢启动则对文件类请求影响较大。</span><br><span class="line"></span><br><span class="line">### https与http的区别</span><br><span class="line"></span><br><span class="line">- https协议需要CA申请证书</span><br><span class="line">- http协议运行在TCP之上，所有传输的内容都是明文，https运行在ssl/tls之上，ssl/tls运行在tcp之上，所有传输的内容都是经过加密的</span><br><span class="line">- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443.</span><br><span class="line">- https可以有效的防止运营商劫持，解决了防劫持的一个大问题。</span><br><span class="line"></span><br><span class="line">### HTTP状态码</span><br><span class="line">- 1** 信息，服务器接收到请求，需要请求者继续执行操作。  </span><br><span class="line">  1. 101切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议。</span><br><span class="line">- 2** 成功，操作被成功接收并处理</span><br><span class="line">- 3** 重定向，需要进一步的操作以完成请求</span><br><span class="line">  1. 304未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。</span><br><span class="line">- 4** 客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">- 5** 服务器错误，服务器在处理请求的过程中发生了错误。</span><br><span class="line"></span><br><span class="line">### GET与POST的区别</span><br><span class="line">- W3C  </span><br><span class="line">  1. 参数的数据类型，GET只接受ASCII字符，而POST没有限制，允许二进制</span><br><span class="line">  2. GET在浏览器回退/刷新时是无害的，而POST会再次提交请求</span><br><span class="line">  3. GET请求只能进行url编码（application/x-www-form-urlencoded）,而POST支持多种编码方式（application/x-www-form-urlencoded或multipart/form-data），可以为二进制使用多重编码。</span><br><span class="line">  4. POST比GET更安全，因为GET参数直接暴露在URL上，POST参数在HTTP消息主体中，而且不会保存在浏览器历史或web服务器日志中。</span><br><span class="line">  5. 对参数数据长度的限制，GET方法URL的长度是受限制的，最大是2048个字符，POST参数数据是没有限制的。</span><br><span class="line">  6. GET请求会被浏览器主动缓存，POST不会，除非手动设置。</span><br><span class="line">  7. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会保留。</span><br><span class="line">  8. GET请求可被收藏为书签，POST不能。</span><br><span class="line"></span><br><span class="line">- WSC</span><br><span class="line">  1. GET和POST本质上都是TCP链接，给GET加上request body，给POST加上url参数，技术上是可行的。但是由于HTTP的规定和浏览器/服务器的限制，导致在应用过程中体现出一些不同。</span><br><span class="line">  2. GET会产生一个TCP数据包，POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## CSS</span><br><span class="line">### BFC</span><br><span class="line">BFC（Block formating context）直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，它规定了北部的block-level-box如何布局，并且与这个区域外部毫不相干。  </span><br><span class="line">形成条件： </span><br><span class="line">- 浮动元素， float除none以外的值</span><br><span class="line">- 定位元素，position（absolute， fixed）</span><br><span class="line">- display为以为其中之一的值，inline-block，table-cell，table-caption</span><br><span class="line">- overflow除了visible以外的值（hidden，scroll，auto）  </span><br><span class="line"></span><br><span class="line">BFC的特性：</span><br><span class="line">- 内部的BOX会在垂直方向上一个接一个的位置</span><br><span class="line">- 垂直方向上的距离由margin决定</span><br><span class="line">- bfc的区域不会于float的元素区域重叠</span><br><span class="line">- 计算bfc的高度时，浮动元素也参与计算</span><br><span class="line">- bfc就是页面上的一个独立容器，容器里面的自元素不会影响外面元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### position: sticky（兼容性比较低）</span><br><span class="line">粘性定位，是position：relative和postion： fixed的结合体。  </span><br><span class="line">生效规则：</span><br><span class="line">- top, right, bottom, left四个阙值其中之一。</span><br><span class="line">- 设定为position：sticky元素的任意父节点的overflow属性必须是visible，否则position不会生效。  </span><br><span class="line"></span><br><span class="line">[参考1](http://www.cnblogs.com/coco1s/p/6402723.html)  </span><br><span class="line">[参考2](https://segmentfault.com/a/1190000006740129)</span><br><span class="line"></span><br><span class="line">### box-sizing</span><br><span class="line"></span><br><span class="line">1. content-box默认值，标准盒子模型。width与height只包括内容的宽和高，不包括边框，内边距，外边距。尺寸计算公式： width = 内容的宽度，height = 内容的高度。宽度和高度都不包含内容的边框（border）和内边距（padding）</span><br><span class="line"></span><br><span class="line">2. border-box width和height属性包括内容，内边距和边框，但不包括外边距。这里的纬度计算公式为： width = border + padding + 内容的width， height = border + padding + 内容的height。</span><br><span class="line"></span><br><span class="line">### css全局污染的解决方案  </span><br><span class="line">我们经常通过class或者id选择器来修改html的样式，并且允许在一个css文件中存在两个class名字一样的样式，但是当多人合作开发一个页面时，难免出现类名重复导致样式互相影响的问题。</span><br><span class="line">1. scoped属性： html5带来了很多强势的功能，其中scoped属性可以让我们更好的控制样式，让其变成局部的。</span><br></pre></td></tr></table></figure></p>
<p><style scoped><br>.class {<br>  ……<br>}<br></style><br>不过存在兼容性问题，在chrome下时无效的，只有在firefox下才有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">2. css in js ： 类似于react中的jsx一样的一个语法糖，你可以命名一个对象变量，然后利用react的style，传对应的style对象进去。</span><br></pre></td></tr></table></figure></p>
<p>const styles = {<br>  bar: {<br>    backgroundColor: ‘red’;<br>  }<br>}<br>const example = (props) =&gt; (<br>  <div style="{styles.bar}"></div><br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. CSS Modules： 现在的网页开发都是通过组件，模块化开发。css modules就是将css模块化的技术。可参考[阮老师的教程](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)。</span><br><span class="line">大致如此： </span><br><span class="line">- 将class编译成哈希字符串</span><br></pre></td></tr></table></figure></p>
<p></p><h1 class="_3zyde4l1yATCOkgn-DBWEL"><br>  Hello World<br></h1><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用webpack的css-loader插件，它对css modules的支持最好。</span><br></pre></td></tr></table></figure><p></p>
<p>module.exports = {<br>  entry: __dirname + ‘/index.js’,<br>  output: {<br>    publicPath: ‘/‘,<br>    filename: ‘./bundle.js’<br>  },<br>  module: {<br>    loaders: [<br>      {<br>        test: /.jsx?$/,<br>        exclude: /node_modules/,<br>        loader: ‘babel’,<br>        query: {<br>          presets: [‘es2015’, ‘stage-0’, ‘react’]<br>        }<br>      },<br>      {<br>        test: /.css$/,<br>        loader: “style-loader!css-loader?modules”<br>      },<br>    ]<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`style-loader!css-loader?modules`最为关键，css-loader后加入查询参数modules表示打开CSS Modules功能。</span><br><span class="line">- 全局作用域  </span><br><span class="line">:global(.className)的语法，表示声明一个全局规则，凡是这样生命的都不会编译成哈希字符串。</span><br><span class="line">- 定制哈希类名  </span><br><span class="line">css-loader默认的哈希算法是[hash:base64]，会将.title编译成._3zyde4l1yATCOkgn-DBWEL这样的字符串。webpack可以定制哈希字符串的格式。</span><br></pre></td></tr></table></figure></p>
<p>module: {<br>  loaders: [<br>    // …<br>    {<br>      test: /.css$/,<br>      loader: “style-loader!css-loader?modules&amp;localIdentName=[path][name]—[local]—[hash:base64:5]”<br>    },<br>  ]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- class的组合</span><br><span class="line"></span><br><span class="line">  在同一个css中</span><br></pre></td></tr></table></figure></p>
<p>.className {<br>  background-color: blue;<br>}</p>
<p>.title {<br>  composes: className;<br>  color: red;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-  其他模块  </span><br><span class="line">antoher.css</span><br></pre></td></tr></table></figure></p>
<p>.className {<br>  background-color: blue;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App.css 可以继承another.css里面的规则</span><br></pre></td></tr></table></figure></p>
<p>.title {<br>  composes: className from ‘./another.css’;<br>  color: red;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 输入变量  </span><br><span class="line">css modules支持使用变量，不过需要安装PostCSS和postcss-modules-values</span><br><span class="line">`npm install --save postcss-loader postcss-modules-values`</span><br><span class="line">把postcss-loader加入webpack.config.js</span><br></pre></td></tr></table></figure></p>
<p>var values = require(‘postcss-modules-values’);</p>
<p>module.exports = {<br>  entry: __dirname + ‘/index.js’,<br>  output: {<br>    publicPath: ‘/‘,<br>    filename: ‘./bundle.js’<br>  },<br>  module: {<br>    loaders: [<br>      {<br>        test: /.jsx?$/,<br>        exclude: /node_modules/,<br>        loader: ‘babel’,<br>        query: {<br>          presets: [‘es2015’, ‘stage-0’, ‘react’]<br>        }<br>      },<br>      {<br>        test: /.css$/,<br>        loader: “style-loader!css-loader?modules!postcss-loader”<br>      },<br>    ]<br>  },<br>  postcss: [<br>    values<br>  ]<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接着，在colors.css里面定义变量</span><br></pre></td></tr></table></figure></p>
<p>@value blue: #0c77f8;<br>@value red: #ff0000;<br>@value green: #aaf200;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App.css可以引用这些变量</span><br></pre></td></tr></table></figure></p>
<p>@value colors: “./colors.css”;<br>@value blue, red, green from colors;</p>
<p>.title {<br>  color: red;<br>  background-color: blue;<br>}<br><code>`</code></p>
<h3 id="table布局的优缺点"><a href="#table布局的优缺点" class="headerlink" title="table布局的优缺点"></a>table布局的优缺点</h3><p>缺点  </p>
<ol>
<li>table比其他html标记占更多的字节（造成下载时间延迟，占用服务器更多流量资源）</li>
<li>table会阻挡浏览器渲染引擎的渲染顺序。（会延迟页面的生成速度，让用户等待更久的时间）</li>
<li>table里面显示图片需要你把单个、有逻辑的图片切成多个图。（增加设计的复杂度，增加页面加载时间，增加http会话数）</li>
<li>限制页面设计的自由性</li>
<li>table对于页面布局来说，从语义上看是不正确的。（它描述的是表现，而不是内容）</li>
<li>不但无法利用css，而且阅读繁琐，尤其是在进行页面改版或内容抽取的时候。</li>
<li>table一旦设计完成就变成死的，很难通过css让它展现新的面貌  </li>
</ol>
<p>优点</p>
<ol>
<li>用table做表格</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KIRIN</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KIRIN</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
